// Code generated by ent, DO NOT EDIT.

package ent

import (
	"backend/ent/blockstorage"
	"backend/ent/instances"
	"backend/ent/ipaddress"
	"backend/ent/loadbalancer"
	"backend/ent/objectstorage"
	"backend/ent/panier"
	"backend/ent/panierblockstorage"
	"backend/ent/panierinstances"
	"backend/ent/panieripaddress"
	"backend/ent/panierloadbalancer"
	"backend/ent/panierobjectstorage"
	"backend/ent/predicate"
	"context"
	"errors"
	"fmt"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBlockStorage        = "BlockStorage"
	TypeIPAddress           = "IPAddress"
	TypeInstances           = "Instances"
	TypeLoadBalancer        = "LoadBalancer"
	TypeObjectStorage       = "ObjectStorage"
	TypePanier              = "Panier"
	TypePanierBlockStorage  = "PanierBlockStorage"
	TypePanierIPAddress     = "PanierIPAddress"
	TypePanierInstances     = "PanierInstances"
	TypePanierLoadBalancer  = "PanierLoadBalancer"
	TypePanierObjectStorage = "PanierObjectStorage"
)

// BlockStorageMutation represents an operation that mutates the BlockStorage nodes in the graph.
type BlockStorageMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	_Name                     *string
	_IOPS                     *int
	add_IOPS                  *int
	_Bandwidth                *float64
	add_Bandwidth             *float64
	_Price                    *float64
	add_Price                 *float64
	clearedFields             map[string]struct{}
	panierBlockStorage        map[int]struct{}
	removedpanierBlockStorage map[int]struct{}
	clearedpanierBlockStorage bool
	done                      bool
	oldValue                  func(context.Context) (*BlockStorage, error)
	predicates                []predicate.BlockStorage
}

var _ ent.Mutation = (*BlockStorageMutation)(nil)

// blockstorageOption allows management of the mutation configuration using functional options.
type blockstorageOption func(*BlockStorageMutation)

// newBlockStorageMutation creates new mutation for the BlockStorage entity.
func newBlockStorageMutation(c config, op Op, opts ...blockstorageOption) *BlockStorageMutation {
	m := &BlockStorageMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockStorage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockStorageID sets the ID field of the mutation.
func withBlockStorageID(id int) blockstorageOption {
	return func(m *BlockStorageMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockStorage
		)
		m.oldValue = func(ctx context.Context) (*BlockStorage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockStorage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockStorage sets the old BlockStorage of the mutation.
func withBlockStorage(node *BlockStorage) blockstorageOption {
	return func(m *BlockStorageMutation) {
		m.oldValue = func(context.Context) (*BlockStorage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockStorageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockStorageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlockStorage entities.
func (m *BlockStorageMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockStorageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockStorageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockStorage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *BlockStorageMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *BlockStorageMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the BlockStorage entity.
// If the BlockStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStorageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *BlockStorageMutation) ResetName() {
	m._Name = nil
}

// SetIOPS sets the "IOPS" field.
func (m *BlockStorageMutation) SetIOPS(i int) {
	m._IOPS = &i
	m.add_IOPS = nil
}

// IOPS returns the value of the "IOPS" field in the mutation.
func (m *BlockStorageMutation) IOPS() (r int, exists bool) {
	v := m._IOPS
	if v == nil {
		return
	}
	return *v, true
}

// OldIOPS returns the old "IOPS" field's value of the BlockStorage entity.
// If the BlockStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStorageMutation) OldIOPS(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIOPS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIOPS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIOPS: %w", err)
	}
	return oldValue.IOPS, nil
}

// AddIOPS adds i to the "IOPS" field.
func (m *BlockStorageMutation) AddIOPS(i int) {
	if m.add_IOPS != nil {
		*m.add_IOPS += i
	} else {
		m.add_IOPS = &i
	}
}

// AddedIOPS returns the value that was added to the "IOPS" field in this mutation.
func (m *BlockStorageMutation) AddedIOPS() (r int, exists bool) {
	v := m.add_IOPS
	if v == nil {
		return
	}
	return *v, true
}

// ResetIOPS resets all changes to the "IOPS" field.
func (m *BlockStorageMutation) ResetIOPS() {
	m._IOPS = nil
	m.add_IOPS = nil
}

// SetBandwidth sets the "Bandwidth" field.
func (m *BlockStorageMutation) SetBandwidth(f float64) {
	m._Bandwidth = &f
	m.add_Bandwidth = nil
}

// Bandwidth returns the value of the "Bandwidth" field in the mutation.
func (m *BlockStorageMutation) Bandwidth() (r float64, exists bool) {
	v := m._Bandwidth
	if v == nil {
		return
	}
	return *v, true
}

// OldBandwidth returns the old "Bandwidth" field's value of the BlockStorage entity.
// If the BlockStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStorageMutation) OldBandwidth(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBandwidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBandwidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBandwidth: %w", err)
	}
	return oldValue.Bandwidth, nil
}

// AddBandwidth adds f to the "Bandwidth" field.
func (m *BlockStorageMutation) AddBandwidth(f float64) {
	if m.add_Bandwidth != nil {
		*m.add_Bandwidth += f
	} else {
		m.add_Bandwidth = &f
	}
}

// AddedBandwidth returns the value that was added to the "Bandwidth" field in this mutation.
func (m *BlockStorageMutation) AddedBandwidth() (r float64, exists bool) {
	v := m.add_Bandwidth
	if v == nil {
		return
	}
	return *v, true
}

// ResetBandwidth resets all changes to the "Bandwidth" field.
func (m *BlockStorageMutation) ResetBandwidth() {
	m._Bandwidth = nil
	m.add_Bandwidth = nil
}

// SetPrice sets the "Price" field.
func (m *BlockStorageMutation) SetPrice(f float64) {
	m._Price = &f
	m.add_Price = nil
}

// Price returns the value of the "Price" field in the mutation.
func (m *BlockStorageMutation) Price() (r float64, exists bool) {
	v := m._Price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "Price" field's value of the BlockStorage entity.
// If the BlockStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStorageMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "Price" field.
func (m *BlockStorageMutation) AddPrice(f float64) {
	if m.add_Price != nil {
		*m.add_Price += f
	} else {
		m.add_Price = &f
	}
}

// AddedPrice returns the value that was added to the "Price" field in this mutation.
func (m *BlockStorageMutation) AddedPrice() (r float64, exists bool) {
	v := m.add_Price
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "Price" field.
func (m *BlockStorageMutation) ResetPrice() {
	m._Price = nil
	m.add_Price = nil
}

// AddPanierBlockStorageIDs adds the "panierBlockStorage" edge to the PanierBlockStorage entity by ids.
func (m *BlockStorageMutation) AddPanierBlockStorageIDs(ids ...int) {
	if m.panierBlockStorage == nil {
		m.panierBlockStorage = make(map[int]struct{})
	}
	for i := range ids {
		m.panierBlockStorage[ids[i]] = struct{}{}
	}
}

// ClearPanierBlockStorage clears the "panierBlockStorage" edge to the PanierBlockStorage entity.
func (m *BlockStorageMutation) ClearPanierBlockStorage() {
	m.clearedpanierBlockStorage = true
}

// PanierBlockStorageCleared reports if the "panierBlockStorage" edge to the PanierBlockStorage entity was cleared.
func (m *BlockStorageMutation) PanierBlockStorageCleared() bool {
	return m.clearedpanierBlockStorage
}

// RemovePanierBlockStorageIDs removes the "panierBlockStorage" edge to the PanierBlockStorage entity by IDs.
func (m *BlockStorageMutation) RemovePanierBlockStorageIDs(ids ...int) {
	if m.removedpanierBlockStorage == nil {
		m.removedpanierBlockStorage = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.panierBlockStorage, ids[i])
		m.removedpanierBlockStorage[ids[i]] = struct{}{}
	}
}

// RemovedPanierBlockStorage returns the removed IDs of the "panierBlockStorage" edge to the PanierBlockStorage entity.
func (m *BlockStorageMutation) RemovedPanierBlockStorageIDs() (ids []int) {
	for id := range m.removedpanierBlockStorage {
		ids = append(ids, id)
	}
	return
}

// PanierBlockStorageIDs returns the "panierBlockStorage" edge IDs in the mutation.
func (m *BlockStorageMutation) PanierBlockStorageIDs() (ids []int) {
	for id := range m.panierBlockStorage {
		ids = append(ids, id)
	}
	return
}

// ResetPanierBlockStorage resets all changes to the "panierBlockStorage" edge.
func (m *BlockStorageMutation) ResetPanierBlockStorage() {
	m.panierBlockStorage = nil
	m.clearedpanierBlockStorage = false
	m.removedpanierBlockStorage = nil
}

// Where appends a list predicates to the BlockStorageMutation builder.
func (m *BlockStorageMutation) Where(ps ...predicate.BlockStorage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockStorageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockStorageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockStorage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockStorageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockStorageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockStorage).
func (m *BlockStorageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockStorageMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._Name != nil {
		fields = append(fields, blockstorage.FieldName)
	}
	if m._IOPS != nil {
		fields = append(fields, blockstorage.FieldIOPS)
	}
	if m._Bandwidth != nil {
		fields = append(fields, blockstorage.FieldBandwidth)
	}
	if m._Price != nil {
		fields = append(fields, blockstorage.FieldPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockStorageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockstorage.FieldName:
		return m.Name()
	case blockstorage.FieldIOPS:
		return m.IOPS()
	case blockstorage.FieldBandwidth:
		return m.Bandwidth()
	case blockstorage.FieldPrice:
		return m.Price()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockStorageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockstorage.FieldName:
		return m.OldName(ctx)
	case blockstorage.FieldIOPS:
		return m.OldIOPS(ctx)
	case blockstorage.FieldBandwidth:
		return m.OldBandwidth(ctx)
	case blockstorage.FieldPrice:
		return m.OldPrice(ctx)
	}
	return nil, fmt.Errorf("unknown BlockStorage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockStorageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockstorage.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case blockstorage.FieldIOPS:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIOPS(v)
		return nil
	case blockstorage.FieldBandwidth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBandwidth(v)
		return nil
	case blockstorage.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	}
	return fmt.Errorf("unknown BlockStorage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockStorageMutation) AddedFields() []string {
	var fields []string
	if m.add_IOPS != nil {
		fields = append(fields, blockstorage.FieldIOPS)
	}
	if m.add_Bandwidth != nil {
		fields = append(fields, blockstorage.FieldBandwidth)
	}
	if m.add_Price != nil {
		fields = append(fields, blockstorage.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockStorageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blockstorage.FieldIOPS:
		return m.AddedIOPS()
	case blockstorage.FieldBandwidth:
		return m.AddedBandwidth()
	case blockstorage.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockStorageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blockstorage.FieldIOPS:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIOPS(v)
		return nil
	case blockstorage.FieldBandwidth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBandwidth(v)
		return nil
	case blockstorage.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown BlockStorage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockStorageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockStorageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockStorageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BlockStorage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockStorageMutation) ResetField(name string) error {
	switch name {
	case blockstorage.FieldName:
		m.ResetName()
		return nil
	case blockstorage.FieldIOPS:
		m.ResetIOPS()
		return nil
	case blockstorage.FieldBandwidth:
		m.ResetBandwidth()
		return nil
	case blockstorage.FieldPrice:
		m.ResetPrice()
		return nil
	}
	return fmt.Errorf("unknown BlockStorage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockStorageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.panierBlockStorage != nil {
		edges = append(edges, blockstorage.EdgePanierBlockStorage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockStorageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blockstorage.EdgePanierBlockStorage:
		ids := make([]ent.Value, 0, len(m.panierBlockStorage))
		for id := range m.panierBlockStorage {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockStorageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpanierBlockStorage != nil {
		edges = append(edges, blockstorage.EdgePanierBlockStorage)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockStorageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blockstorage.EdgePanierBlockStorage:
		ids := make([]ent.Value, 0, len(m.removedpanierBlockStorage))
		for id := range m.removedpanierBlockStorage {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockStorageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpanierBlockStorage {
		edges = append(edges, blockstorage.EdgePanierBlockStorage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockStorageMutation) EdgeCleared(name string) bool {
	switch name {
	case blockstorage.EdgePanierBlockStorage:
		return m.clearedpanierBlockStorage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockStorageMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BlockStorage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockStorageMutation) ResetEdge(name string) error {
	switch name {
	case blockstorage.EdgePanierBlockStorage:
		m.ResetPanierBlockStorage()
		return nil
	}
	return fmt.Errorf("unknown BlockStorage edge %s", name)
}

// IPAddressMutation represents an operation that mutates the IPAddress nodes in the graph.
type IPAddressMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	_Name                  *string
	_Price                 *float64
	add_Price              *float64
	clearedFields          map[string]struct{}
	panierIPAddress        map[int]struct{}
	removedpanierIPAddress map[int]struct{}
	clearedpanierIPAddress bool
	done                   bool
	oldValue               func(context.Context) (*IPAddress, error)
	predicates             []predicate.IPAddress
}

var _ ent.Mutation = (*IPAddressMutation)(nil)

// ipaddressOption allows management of the mutation configuration using functional options.
type ipaddressOption func(*IPAddressMutation)

// newIPAddressMutation creates new mutation for the IPAddress entity.
func newIPAddressMutation(c config, op Op, opts ...ipaddressOption) *IPAddressMutation {
	m := &IPAddressMutation{
		config:        c,
		op:            op,
		typ:           TypeIPAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIPAddressID sets the ID field of the mutation.
func withIPAddressID(id int) ipaddressOption {
	return func(m *IPAddressMutation) {
		var (
			err   error
			once  sync.Once
			value *IPAddress
		)
		m.oldValue = func(ctx context.Context) (*IPAddress, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IPAddress.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIPAddress sets the old IPAddress of the mutation.
func withIPAddress(node *IPAddress) ipaddressOption {
	return func(m *IPAddressMutation) {
		m.oldValue = func(context.Context) (*IPAddress, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IPAddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IPAddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IPAddress entities.
func (m *IPAddressMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IPAddressMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IPAddressMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IPAddress.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *IPAddressMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *IPAddressMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the IPAddress entity.
// If the IPAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPAddressMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *IPAddressMutation) ResetName() {
	m._Name = nil
}

// SetPrice sets the "Price" field.
func (m *IPAddressMutation) SetPrice(f float64) {
	m._Price = &f
	m.add_Price = nil
}

// Price returns the value of the "Price" field in the mutation.
func (m *IPAddressMutation) Price() (r float64, exists bool) {
	v := m._Price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "Price" field's value of the IPAddress entity.
// If the IPAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPAddressMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "Price" field.
func (m *IPAddressMutation) AddPrice(f float64) {
	if m.add_Price != nil {
		*m.add_Price += f
	} else {
		m.add_Price = &f
	}
}

// AddedPrice returns the value that was added to the "Price" field in this mutation.
func (m *IPAddressMutation) AddedPrice() (r float64, exists bool) {
	v := m.add_Price
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "Price" field.
func (m *IPAddressMutation) ResetPrice() {
	m._Price = nil
	m.add_Price = nil
}

// AddPanierIPAddresIDs adds the "panierIPAddress" edge to the PanierIPAddress entity by ids.
func (m *IPAddressMutation) AddPanierIPAddresIDs(ids ...int) {
	if m.panierIPAddress == nil {
		m.panierIPAddress = make(map[int]struct{})
	}
	for i := range ids {
		m.panierIPAddress[ids[i]] = struct{}{}
	}
}

// ClearPanierIPAddress clears the "panierIPAddress" edge to the PanierIPAddress entity.
func (m *IPAddressMutation) ClearPanierIPAddress() {
	m.clearedpanierIPAddress = true
}

// PanierIPAddressCleared reports if the "panierIPAddress" edge to the PanierIPAddress entity was cleared.
func (m *IPAddressMutation) PanierIPAddressCleared() bool {
	return m.clearedpanierIPAddress
}

// RemovePanierIPAddresIDs removes the "panierIPAddress" edge to the PanierIPAddress entity by IDs.
func (m *IPAddressMutation) RemovePanierIPAddresIDs(ids ...int) {
	if m.removedpanierIPAddress == nil {
		m.removedpanierIPAddress = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.panierIPAddress, ids[i])
		m.removedpanierIPAddress[ids[i]] = struct{}{}
	}
}

// RemovedPanierIPAddress returns the removed IDs of the "panierIPAddress" edge to the PanierIPAddress entity.
func (m *IPAddressMutation) RemovedPanierIPAddressIDs() (ids []int) {
	for id := range m.removedpanierIPAddress {
		ids = append(ids, id)
	}
	return
}

// PanierIPAddressIDs returns the "panierIPAddress" edge IDs in the mutation.
func (m *IPAddressMutation) PanierIPAddressIDs() (ids []int) {
	for id := range m.panierIPAddress {
		ids = append(ids, id)
	}
	return
}

// ResetPanierIPAddress resets all changes to the "panierIPAddress" edge.
func (m *IPAddressMutation) ResetPanierIPAddress() {
	m.panierIPAddress = nil
	m.clearedpanierIPAddress = false
	m.removedpanierIPAddress = nil
}

// Where appends a list predicates to the IPAddressMutation builder.
func (m *IPAddressMutation) Where(ps ...predicate.IPAddress) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IPAddressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IPAddressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IPAddress, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IPAddressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IPAddressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IPAddress).
func (m *IPAddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IPAddressMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._Name != nil {
		fields = append(fields, ipaddress.FieldName)
	}
	if m._Price != nil {
		fields = append(fields, ipaddress.FieldPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IPAddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ipaddress.FieldName:
		return m.Name()
	case ipaddress.FieldPrice:
		return m.Price()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IPAddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ipaddress.FieldName:
		return m.OldName(ctx)
	case ipaddress.FieldPrice:
		return m.OldPrice(ctx)
	}
	return nil, fmt.Errorf("unknown IPAddress field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IPAddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ipaddress.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ipaddress.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	}
	return fmt.Errorf("unknown IPAddress field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IPAddressMutation) AddedFields() []string {
	var fields []string
	if m.add_Price != nil {
		fields = append(fields, ipaddress.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IPAddressMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ipaddress.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IPAddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ipaddress.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown IPAddress numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IPAddressMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IPAddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IPAddressMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IPAddress nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IPAddressMutation) ResetField(name string) error {
	switch name {
	case ipaddress.FieldName:
		m.ResetName()
		return nil
	case ipaddress.FieldPrice:
		m.ResetPrice()
		return nil
	}
	return fmt.Errorf("unknown IPAddress field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IPAddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.panierIPAddress != nil {
		edges = append(edges, ipaddress.EdgePanierIPAddress)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IPAddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ipaddress.EdgePanierIPAddress:
		ids := make([]ent.Value, 0, len(m.panierIPAddress))
		for id := range m.panierIPAddress {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IPAddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpanierIPAddress != nil {
		edges = append(edges, ipaddress.EdgePanierIPAddress)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IPAddressMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ipaddress.EdgePanierIPAddress:
		ids := make([]ent.Value, 0, len(m.removedpanierIPAddress))
		for id := range m.removedpanierIPAddress {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IPAddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpanierIPAddress {
		edges = append(edges, ipaddress.EdgePanierIPAddress)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IPAddressMutation) EdgeCleared(name string) bool {
	switch name {
	case ipaddress.EdgePanierIPAddress:
		return m.clearedpanierIPAddress
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IPAddressMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown IPAddress unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IPAddressMutation) ResetEdge(name string) error {
	switch name {
	case ipaddress.EdgePanierIPAddress:
		m.ResetPanierIPAddress()
		return nil
	}
	return fmt.Errorf("unknown IPAddress edge %s", name)
}

// InstancesMutation represents an operation that mutates the Instances nodes in the graph.
type InstancesMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	_Name                  *string
	_CPU                   *int
	add_CPU                *int
	_Ram_Go                *int
	add_Ram_Go             *int
	_Stockage_Go           *int
	add_Stockage_Go        *int
	_GPU                   *string
	_Type                  *string
	_Price                 *float64
	add_Price              *float64
	clearedFields          map[string]struct{}
	panierInstances        map[int]struct{}
	removedpanierInstances map[int]struct{}
	clearedpanierInstances bool
	done                   bool
	oldValue               func(context.Context) (*Instances, error)
	predicates             []predicate.Instances
}

var _ ent.Mutation = (*InstancesMutation)(nil)

// instancesOption allows management of the mutation configuration using functional options.
type instancesOption func(*InstancesMutation)

// newInstancesMutation creates new mutation for the Instances entity.
func newInstancesMutation(c config, op Op, opts ...instancesOption) *InstancesMutation {
	m := &InstancesMutation{
		config:        c,
		op:            op,
		typ:           TypeInstances,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInstancesID sets the ID field of the mutation.
func withInstancesID(id int) instancesOption {
	return func(m *InstancesMutation) {
		var (
			err   error
			once  sync.Once
			value *Instances
		)
		m.oldValue = func(ctx context.Context) (*Instances, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Instances.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInstances sets the old Instances of the mutation.
func withInstances(node *Instances) instancesOption {
	return func(m *InstancesMutation) {
		m.oldValue = func(context.Context) (*Instances, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InstancesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InstancesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Instances entities.
func (m *InstancesMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InstancesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InstancesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Instances.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *InstancesMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *InstancesMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Instances entity.
// If the Instances object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstancesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *InstancesMutation) ResetName() {
	m._Name = nil
}

// SetCPU sets the "CPU" field.
func (m *InstancesMutation) SetCPU(i int) {
	m._CPU = &i
	m.add_CPU = nil
}

// CPU returns the value of the "CPU" field in the mutation.
func (m *InstancesMutation) CPU() (r int, exists bool) {
	v := m._CPU
	if v == nil {
		return
	}
	return *v, true
}

// OldCPU returns the old "CPU" field's value of the Instances entity.
// If the Instances object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstancesMutation) OldCPU(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPU is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPU requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPU: %w", err)
	}
	return oldValue.CPU, nil
}

// AddCPU adds i to the "CPU" field.
func (m *InstancesMutation) AddCPU(i int) {
	if m.add_CPU != nil {
		*m.add_CPU += i
	} else {
		m.add_CPU = &i
	}
}

// AddedCPU returns the value that was added to the "CPU" field in this mutation.
func (m *InstancesMutation) AddedCPU() (r int, exists bool) {
	v := m.add_CPU
	if v == nil {
		return
	}
	return *v, true
}

// ResetCPU resets all changes to the "CPU" field.
func (m *InstancesMutation) ResetCPU() {
	m._CPU = nil
	m.add_CPU = nil
}

// SetRAMGo sets the "Ram_Go" field.
func (m *InstancesMutation) SetRAMGo(i int) {
	m._Ram_Go = &i
	m.add_Ram_Go = nil
}

// RAMGo returns the value of the "Ram_Go" field in the mutation.
func (m *InstancesMutation) RAMGo() (r int, exists bool) {
	v := m._Ram_Go
	if v == nil {
		return
	}
	return *v, true
}

// OldRAMGo returns the old "Ram_Go" field's value of the Instances entity.
// If the Instances object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstancesMutation) OldRAMGo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRAMGo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRAMGo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRAMGo: %w", err)
	}
	return oldValue.RAMGo, nil
}

// AddRAMGo adds i to the "Ram_Go" field.
func (m *InstancesMutation) AddRAMGo(i int) {
	if m.add_Ram_Go != nil {
		*m.add_Ram_Go += i
	} else {
		m.add_Ram_Go = &i
	}
}

// AddedRAMGo returns the value that was added to the "Ram_Go" field in this mutation.
func (m *InstancesMutation) AddedRAMGo() (r int, exists bool) {
	v := m.add_Ram_Go
	if v == nil {
		return
	}
	return *v, true
}

// ResetRAMGo resets all changes to the "Ram_Go" field.
func (m *InstancesMutation) ResetRAMGo() {
	m._Ram_Go = nil
	m.add_Ram_Go = nil
}

// SetStockageGo sets the "Stockage_Go" field.
func (m *InstancesMutation) SetStockageGo(i int) {
	m._Stockage_Go = &i
	m.add_Stockage_Go = nil
}

// StockageGo returns the value of the "Stockage_Go" field in the mutation.
func (m *InstancesMutation) StockageGo() (r int, exists bool) {
	v := m._Stockage_Go
	if v == nil {
		return
	}
	return *v, true
}

// OldStockageGo returns the old "Stockage_Go" field's value of the Instances entity.
// If the Instances object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstancesMutation) OldStockageGo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStockageGo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStockageGo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStockageGo: %w", err)
	}
	return oldValue.StockageGo, nil
}

// AddStockageGo adds i to the "Stockage_Go" field.
func (m *InstancesMutation) AddStockageGo(i int) {
	if m.add_Stockage_Go != nil {
		*m.add_Stockage_Go += i
	} else {
		m.add_Stockage_Go = &i
	}
}

// AddedStockageGo returns the value that was added to the "Stockage_Go" field in this mutation.
func (m *InstancesMutation) AddedStockageGo() (r int, exists bool) {
	v := m.add_Stockage_Go
	if v == nil {
		return
	}
	return *v, true
}

// ResetStockageGo resets all changes to the "Stockage_Go" field.
func (m *InstancesMutation) ResetStockageGo() {
	m._Stockage_Go = nil
	m.add_Stockage_Go = nil
}

// SetGPU sets the "GPU" field.
func (m *InstancesMutation) SetGPU(s string) {
	m._GPU = &s
}

// GPU returns the value of the "GPU" field in the mutation.
func (m *InstancesMutation) GPU() (r string, exists bool) {
	v := m._GPU
	if v == nil {
		return
	}
	return *v, true
}

// OldGPU returns the old "GPU" field's value of the Instances entity.
// If the Instances object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstancesMutation) OldGPU(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGPU is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGPU requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGPU: %w", err)
	}
	return oldValue.GPU, nil
}

// ResetGPU resets all changes to the "GPU" field.
func (m *InstancesMutation) ResetGPU() {
	m._GPU = nil
}

// SetType sets the "Type" field.
func (m *InstancesMutation) SetType(s string) {
	m._Type = &s
}

// GetType returns the value of the "Type" field in the mutation.
func (m *InstancesMutation) GetType() (r string, exists bool) {
	v := m._Type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "Type" field's value of the Instances entity.
// If the Instances object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstancesMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "Type" field.
func (m *InstancesMutation) ResetType() {
	m._Type = nil
}

// SetPrice sets the "Price" field.
func (m *InstancesMutation) SetPrice(f float64) {
	m._Price = &f
	m.add_Price = nil
}

// Price returns the value of the "Price" field in the mutation.
func (m *InstancesMutation) Price() (r float64, exists bool) {
	v := m._Price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "Price" field's value of the Instances entity.
// If the Instances object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstancesMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "Price" field.
func (m *InstancesMutation) AddPrice(f float64) {
	if m.add_Price != nil {
		*m.add_Price += f
	} else {
		m.add_Price = &f
	}
}

// AddedPrice returns the value that was added to the "Price" field in this mutation.
func (m *InstancesMutation) AddedPrice() (r float64, exists bool) {
	v := m.add_Price
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "Price" field.
func (m *InstancesMutation) ResetPrice() {
	m._Price = nil
	m.add_Price = nil
}

// AddPanierInstanceIDs adds the "panierInstances" edge to the PanierInstances entity by ids.
func (m *InstancesMutation) AddPanierInstanceIDs(ids ...int) {
	if m.panierInstances == nil {
		m.panierInstances = make(map[int]struct{})
	}
	for i := range ids {
		m.panierInstances[ids[i]] = struct{}{}
	}
}

// ClearPanierInstances clears the "panierInstances" edge to the PanierInstances entity.
func (m *InstancesMutation) ClearPanierInstances() {
	m.clearedpanierInstances = true
}

// PanierInstancesCleared reports if the "panierInstances" edge to the PanierInstances entity was cleared.
func (m *InstancesMutation) PanierInstancesCleared() bool {
	return m.clearedpanierInstances
}

// RemovePanierInstanceIDs removes the "panierInstances" edge to the PanierInstances entity by IDs.
func (m *InstancesMutation) RemovePanierInstanceIDs(ids ...int) {
	if m.removedpanierInstances == nil {
		m.removedpanierInstances = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.panierInstances, ids[i])
		m.removedpanierInstances[ids[i]] = struct{}{}
	}
}

// RemovedPanierInstances returns the removed IDs of the "panierInstances" edge to the PanierInstances entity.
func (m *InstancesMutation) RemovedPanierInstancesIDs() (ids []int) {
	for id := range m.removedpanierInstances {
		ids = append(ids, id)
	}
	return
}

// PanierInstancesIDs returns the "panierInstances" edge IDs in the mutation.
func (m *InstancesMutation) PanierInstancesIDs() (ids []int) {
	for id := range m.panierInstances {
		ids = append(ids, id)
	}
	return
}

// ResetPanierInstances resets all changes to the "panierInstances" edge.
func (m *InstancesMutation) ResetPanierInstances() {
	m.panierInstances = nil
	m.clearedpanierInstances = false
	m.removedpanierInstances = nil
}

// Where appends a list predicates to the InstancesMutation builder.
func (m *InstancesMutation) Where(ps ...predicate.Instances) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InstancesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InstancesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Instances, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InstancesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InstancesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Instances).
func (m *InstancesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InstancesMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._Name != nil {
		fields = append(fields, instances.FieldName)
	}
	if m._CPU != nil {
		fields = append(fields, instances.FieldCPU)
	}
	if m._Ram_Go != nil {
		fields = append(fields, instances.FieldRAMGo)
	}
	if m._Stockage_Go != nil {
		fields = append(fields, instances.FieldStockageGo)
	}
	if m._GPU != nil {
		fields = append(fields, instances.FieldGPU)
	}
	if m._Type != nil {
		fields = append(fields, instances.FieldType)
	}
	if m._Price != nil {
		fields = append(fields, instances.FieldPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InstancesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case instances.FieldName:
		return m.Name()
	case instances.FieldCPU:
		return m.CPU()
	case instances.FieldRAMGo:
		return m.RAMGo()
	case instances.FieldStockageGo:
		return m.StockageGo()
	case instances.FieldGPU:
		return m.GPU()
	case instances.FieldType:
		return m.GetType()
	case instances.FieldPrice:
		return m.Price()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InstancesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case instances.FieldName:
		return m.OldName(ctx)
	case instances.FieldCPU:
		return m.OldCPU(ctx)
	case instances.FieldRAMGo:
		return m.OldRAMGo(ctx)
	case instances.FieldStockageGo:
		return m.OldStockageGo(ctx)
	case instances.FieldGPU:
		return m.OldGPU(ctx)
	case instances.FieldType:
		return m.OldType(ctx)
	case instances.FieldPrice:
		return m.OldPrice(ctx)
	}
	return nil, fmt.Errorf("unknown Instances field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstancesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case instances.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case instances.FieldCPU:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPU(v)
		return nil
	case instances.FieldRAMGo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRAMGo(v)
		return nil
	case instances.FieldStockageGo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStockageGo(v)
		return nil
	case instances.FieldGPU:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGPU(v)
		return nil
	case instances.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case instances.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Instances field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InstancesMutation) AddedFields() []string {
	var fields []string
	if m.add_CPU != nil {
		fields = append(fields, instances.FieldCPU)
	}
	if m.add_Ram_Go != nil {
		fields = append(fields, instances.FieldRAMGo)
	}
	if m.add_Stockage_Go != nil {
		fields = append(fields, instances.FieldStockageGo)
	}
	if m.add_Price != nil {
		fields = append(fields, instances.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InstancesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case instances.FieldCPU:
		return m.AddedCPU()
	case instances.FieldRAMGo:
		return m.AddedRAMGo()
	case instances.FieldStockageGo:
		return m.AddedStockageGo()
	case instances.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstancesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case instances.FieldCPU:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPU(v)
		return nil
	case instances.FieldRAMGo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRAMGo(v)
		return nil
	case instances.FieldStockageGo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStockageGo(v)
		return nil
	case instances.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Instances numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InstancesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InstancesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InstancesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Instances nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InstancesMutation) ResetField(name string) error {
	switch name {
	case instances.FieldName:
		m.ResetName()
		return nil
	case instances.FieldCPU:
		m.ResetCPU()
		return nil
	case instances.FieldRAMGo:
		m.ResetRAMGo()
		return nil
	case instances.FieldStockageGo:
		m.ResetStockageGo()
		return nil
	case instances.FieldGPU:
		m.ResetGPU()
		return nil
	case instances.FieldType:
		m.ResetType()
		return nil
	case instances.FieldPrice:
		m.ResetPrice()
		return nil
	}
	return fmt.Errorf("unknown Instances field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InstancesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.panierInstances != nil {
		edges = append(edges, instances.EdgePanierInstances)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InstancesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case instances.EdgePanierInstances:
		ids := make([]ent.Value, 0, len(m.panierInstances))
		for id := range m.panierInstances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InstancesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpanierInstances != nil {
		edges = append(edges, instances.EdgePanierInstances)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InstancesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case instances.EdgePanierInstances:
		ids := make([]ent.Value, 0, len(m.removedpanierInstances))
		for id := range m.removedpanierInstances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InstancesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpanierInstances {
		edges = append(edges, instances.EdgePanierInstances)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InstancesMutation) EdgeCleared(name string) bool {
	switch name {
	case instances.EdgePanierInstances:
		return m.clearedpanierInstances
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InstancesMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Instances unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InstancesMutation) ResetEdge(name string) error {
	switch name {
	case instances.EdgePanierInstances:
		m.ResetPanierInstances()
		return nil
	}
	return fmt.Errorf("unknown Instances edge %s", name)
}

// LoadBalancerMutation represents an operation that mutates the LoadBalancer nodes in the graph.
type LoadBalancerMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	_Name                     *string
	_Price                    *float64
	add_Price                 *float64
	clearedFields             map[string]struct{}
	panierLoadBalancer        map[int]struct{}
	removedpanierLoadBalancer map[int]struct{}
	clearedpanierLoadBalancer bool
	done                      bool
	oldValue                  func(context.Context) (*LoadBalancer, error)
	predicates                []predicate.LoadBalancer
}

var _ ent.Mutation = (*LoadBalancerMutation)(nil)

// loadbalancerOption allows management of the mutation configuration using functional options.
type loadbalancerOption func(*LoadBalancerMutation)

// newLoadBalancerMutation creates new mutation for the LoadBalancer entity.
func newLoadBalancerMutation(c config, op Op, opts ...loadbalancerOption) *LoadBalancerMutation {
	m := &LoadBalancerMutation{
		config:        c,
		op:            op,
		typ:           TypeLoadBalancer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLoadBalancerID sets the ID field of the mutation.
func withLoadBalancerID(id int) loadbalancerOption {
	return func(m *LoadBalancerMutation) {
		var (
			err   error
			once  sync.Once
			value *LoadBalancer
		)
		m.oldValue = func(ctx context.Context) (*LoadBalancer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LoadBalancer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLoadBalancer sets the old LoadBalancer of the mutation.
func withLoadBalancer(node *LoadBalancer) loadbalancerOption {
	return func(m *LoadBalancerMutation) {
		m.oldValue = func(context.Context) (*LoadBalancer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LoadBalancerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LoadBalancerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LoadBalancer entities.
func (m *LoadBalancerMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LoadBalancerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LoadBalancerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LoadBalancer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *LoadBalancerMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *LoadBalancerMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the LoadBalancer entity.
// If the LoadBalancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoadBalancerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *LoadBalancerMutation) ResetName() {
	m._Name = nil
}

// SetPrice sets the "Price" field.
func (m *LoadBalancerMutation) SetPrice(f float64) {
	m._Price = &f
	m.add_Price = nil
}

// Price returns the value of the "Price" field in the mutation.
func (m *LoadBalancerMutation) Price() (r float64, exists bool) {
	v := m._Price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "Price" field's value of the LoadBalancer entity.
// If the LoadBalancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoadBalancerMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "Price" field.
func (m *LoadBalancerMutation) AddPrice(f float64) {
	if m.add_Price != nil {
		*m.add_Price += f
	} else {
		m.add_Price = &f
	}
}

// AddedPrice returns the value that was added to the "Price" field in this mutation.
func (m *LoadBalancerMutation) AddedPrice() (r float64, exists bool) {
	v := m.add_Price
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "Price" field.
func (m *LoadBalancerMutation) ResetPrice() {
	m._Price = nil
	m.add_Price = nil
}

// AddPanierLoadBalancerIDs adds the "panierLoadBalancer" edge to the PanierLoadBalancer entity by ids.
func (m *LoadBalancerMutation) AddPanierLoadBalancerIDs(ids ...int) {
	if m.panierLoadBalancer == nil {
		m.panierLoadBalancer = make(map[int]struct{})
	}
	for i := range ids {
		m.panierLoadBalancer[ids[i]] = struct{}{}
	}
}

// ClearPanierLoadBalancer clears the "panierLoadBalancer" edge to the PanierLoadBalancer entity.
func (m *LoadBalancerMutation) ClearPanierLoadBalancer() {
	m.clearedpanierLoadBalancer = true
}

// PanierLoadBalancerCleared reports if the "panierLoadBalancer" edge to the PanierLoadBalancer entity was cleared.
func (m *LoadBalancerMutation) PanierLoadBalancerCleared() bool {
	return m.clearedpanierLoadBalancer
}

// RemovePanierLoadBalancerIDs removes the "panierLoadBalancer" edge to the PanierLoadBalancer entity by IDs.
func (m *LoadBalancerMutation) RemovePanierLoadBalancerIDs(ids ...int) {
	if m.removedpanierLoadBalancer == nil {
		m.removedpanierLoadBalancer = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.panierLoadBalancer, ids[i])
		m.removedpanierLoadBalancer[ids[i]] = struct{}{}
	}
}

// RemovedPanierLoadBalancer returns the removed IDs of the "panierLoadBalancer" edge to the PanierLoadBalancer entity.
func (m *LoadBalancerMutation) RemovedPanierLoadBalancerIDs() (ids []int) {
	for id := range m.removedpanierLoadBalancer {
		ids = append(ids, id)
	}
	return
}

// PanierLoadBalancerIDs returns the "panierLoadBalancer" edge IDs in the mutation.
func (m *LoadBalancerMutation) PanierLoadBalancerIDs() (ids []int) {
	for id := range m.panierLoadBalancer {
		ids = append(ids, id)
	}
	return
}

// ResetPanierLoadBalancer resets all changes to the "panierLoadBalancer" edge.
func (m *LoadBalancerMutation) ResetPanierLoadBalancer() {
	m.panierLoadBalancer = nil
	m.clearedpanierLoadBalancer = false
	m.removedpanierLoadBalancer = nil
}

// Where appends a list predicates to the LoadBalancerMutation builder.
func (m *LoadBalancerMutation) Where(ps ...predicate.LoadBalancer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LoadBalancerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LoadBalancerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LoadBalancer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LoadBalancerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LoadBalancerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LoadBalancer).
func (m *LoadBalancerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LoadBalancerMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._Name != nil {
		fields = append(fields, loadbalancer.FieldName)
	}
	if m._Price != nil {
		fields = append(fields, loadbalancer.FieldPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LoadBalancerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case loadbalancer.FieldName:
		return m.Name()
	case loadbalancer.FieldPrice:
		return m.Price()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LoadBalancerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case loadbalancer.FieldName:
		return m.OldName(ctx)
	case loadbalancer.FieldPrice:
		return m.OldPrice(ctx)
	}
	return nil, fmt.Errorf("unknown LoadBalancer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoadBalancerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case loadbalancer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case loadbalancer.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	}
	return fmt.Errorf("unknown LoadBalancer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LoadBalancerMutation) AddedFields() []string {
	var fields []string
	if m.add_Price != nil {
		fields = append(fields, loadbalancer.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LoadBalancerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case loadbalancer.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoadBalancerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case loadbalancer.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown LoadBalancer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LoadBalancerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LoadBalancerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LoadBalancerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LoadBalancer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LoadBalancerMutation) ResetField(name string) error {
	switch name {
	case loadbalancer.FieldName:
		m.ResetName()
		return nil
	case loadbalancer.FieldPrice:
		m.ResetPrice()
		return nil
	}
	return fmt.Errorf("unknown LoadBalancer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LoadBalancerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.panierLoadBalancer != nil {
		edges = append(edges, loadbalancer.EdgePanierLoadBalancer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LoadBalancerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case loadbalancer.EdgePanierLoadBalancer:
		ids := make([]ent.Value, 0, len(m.panierLoadBalancer))
		for id := range m.panierLoadBalancer {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LoadBalancerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpanierLoadBalancer != nil {
		edges = append(edges, loadbalancer.EdgePanierLoadBalancer)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LoadBalancerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case loadbalancer.EdgePanierLoadBalancer:
		ids := make([]ent.Value, 0, len(m.removedpanierLoadBalancer))
		for id := range m.removedpanierLoadBalancer {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LoadBalancerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpanierLoadBalancer {
		edges = append(edges, loadbalancer.EdgePanierLoadBalancer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LoadBalancerMutation) EdgeCleared(name string) bool {
	switch name {
	case loadbalancer.EdgePanierLoadBalancer:
		return m.clearedpanierLoadBalancer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LoadBalancerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown LoadBalancer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LoadBalancerMutation) ResetEdge(name string) error {
	switch name {
	case loadbalancer.EdgePanierLoadBalancer:
		m.ResetPanierLoadBalancer()
		return nil
	}
	return fmt.Errorf("unknown LoadBalancer edge %s", name)
}

// ObjectStorageMutation represents an operation that mutates the ObjectStorage nodes in the graph.
type ObjectStorageMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	_Name                      *string
	_Price                     *float64
	add_Price                  *float64
	clearedFields              map[string]struct{}
	panierObjectStorage        map[int]struct{}
	removedpanierObjectStorage map[int]struct{}
	clearedpanierObjectStorage bool
	done                       bool
	oldValue                   func(context.Context) (*ObjectStorage, error)
	predicates                 []predicate.ObjectStorage
}

var _ ent.Mutation = (*ObjectStorageMutation)(nil)

// objectstorageOption allows management of the mutation configuration using functional options.
type objectstorageOption func(*ObjectStorageMutation)

// newObjectStorageMutation creates new mutation for the ObjectStorage entity.
func newObjectStorageMutation(c config, op Op, opts ...objectstorageOption) *ObjectStorageMutation {
	m := &ObjectStorageMutation{
		config:        c,
		op:            op,
		typ:           TypeObjectStorage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withObjectStorageID sets the ID field of the mutation.
func withObjectStorageID(id int) objectstorageOption {
	return func(m *ObjectStorageMutation) {
		var (
			err   error
			once  sync.Once
			value *ObjectStorage
		)
		m.oldValue = func(ctx context.Context) (*ObjectStorage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ObjectStorage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withObjectStorage sets the old ObjectStorage of the mutation.
func withObjectStorage(node *ObjectStorage) objectstorageOption {
	return func(m *ObjectStorageMutation) {
		m.oldValue = func(context.Context) (*ObjectStorage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ObjectStorageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ObjectStorageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ObjectStorage entities.
func (m *ObjectStorageMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ObjectStorageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ObjectStorageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ObjectStorage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *ObjectStorageMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *ObjectStorageMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the ObjectStorage entity.
// If the ObjectStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectStorageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *ObjectStorageMutation) ResetName() {
	m._Name = nil
}

// SetPrice sets the "Price" field.
func (m *ObjectStorageMutation) SetPrice(f float64) {
	m._Price = &f
	m.add_Price = nil
}

// Price returns the value of the "Price" field in the mutation.
func (m *ObjectStorageMutation) Price() (r float64, exists bool) {
	v := m._Price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "Price" field's value of the ObjectStorage entity.
// If the ObjectStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectStorageMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "Price" field.
func (m *ObjectStorageMutation) AddPrice(f float64) {
	if m.add_Price != nil {
		*m.add_Price += f
	} else {
		m.add_Price = &f
	}
}

// AddedPrice returns the value that was added to the "Price" field in this mutation.
func (m *ObjectStorageMutation) AddedPrice() (r float64, exists bool) {
	v := m.add_Price
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "Price" field.
func (m *ObjectStorageMutation) ResetPrice() {
	m._Price = nil
	m.add_Price = nil
}

// AddPanierObjectStorageIDs adds the "panierObjectStorage" edge to the PanierObjectStorage entity by ids.
func (m *ObjectStorageMutation) AddPanierObjectStorageIDs(ids ...int) {
	if m.panierObjectStorage == nil {
		m.panierObjectStorage = make(map[int]struct{})
	}
	for i := range ids {
		m.panierObjectStorage[ids[i]] = struct{}{}
	}
}

// ClearPanierObjectStorage clears the "panierObjectStorage" edge to the PanierObjectStorage entity.
func (m *ObjectStorageMutation) ClearPanierObjectStorage() {
	m.clearedpanierObjectStorage = true
}

// PanierObjectStorageCleared reports if the "panierObjectStorage" edge to the PanierObjectStorage entity was cleared.
func (m *ObjectStorageMutation) PanierObjectStorageCleared() bool {
	return m.clearedpanierObjectStorage
}

// RemovePanierObjectStorageIDs removes the "panierObjectStorage" edge to the PanierObjectStorage entity by IDs.
func (m *ObjectStorageMutation) RemovePanierObjectStorageIDs(ids ...int) {
	if m.removedpanierObjectStorage == nil {
		m.removedpanierObjectStorage = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.panierObjectStorage, ids[i])
		m.removedpanierObjectStorage[ids[i]] = struct{}{}
	}
}

// RemovedPanierObjectStorage returns the removed IDs of the "panierObjectStorage" edge to the PanierObjectStorage entity.
func (m *ObjectStorageMutation) RemovedPanierObjectStorageIDs() (ids []int) {
	for id := range m.removedpanierObjectStorage {
		ids = append(ids, id)
	}
	return
}

// PanierObjectStorageIDs returns the "panierObjectStorage" edge IDs in the mutation.
func (m *ObjectStorageMutation) PanierObjectStorageIDs() (ids []int) {
	for id := range m.panierObjectStorage {
		ids = append(ids, id)
	}
	return
}

// ResetPanierObjectStorage resets all changes to the "panierObjectStorage" edge.
func (m *ObjectStorageMutation) ResetPanierObjectStorage() {
	m.panierObjectStorage = nil
	m.clearedpanierObjectStorage = false
	m.removedpanierObjectStorage = nil
}

// Where appends a list predicates to the ObjectStorageMutation builder.
func (m *ObjectStorageMutation) Where(ps ...predicate.ObjectStorage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ObjectStorageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ObjectStorageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ObjectStorage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ObjectStorageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ObjectStorageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ObjectStorage).
func (m *ObjectStorageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ObjectStorageMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._Name != nil {
		fields = append(fields, objectstorage.FieldName)
	}
	if m._Price != nil {
		fields = append(fields, objectstorage.FieldPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ObjectStorageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case objectstorage.FieldName:
		return m.Name()
	case objectstorage.FieldPrice:
		return m.Price()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ObjectStorageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case objectstorage.FieldName:
		return m.OldName(ctx)
	case objectstorage.FieldPrice:
		return m.OldPrice(ctx)
	}
	return nil, fmt.Errorf("unknown ObjectStorage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ObjectStorageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case objectstorage.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case objectstorage.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	}
	return fmt.Errorf("unknown ObjectStorage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ObjectStorageMutation) AddedFields() []string {
	var fields []string
	if m.add_Price != nil {
		fields = append(fields, objectstorage.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ObjectStorageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case objectstorage.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ObjectStorageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case objectstorage.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown ObjectStorage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ObjectStorageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ObjectStorageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ObjectStorageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ObjectStorage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ObjectStorageMutation) ResetField(name string) error {
	switch name {
	case objectstorage.FieldName:
		m.ResetName()
		return nil
	case objectstorage.FieldPrice:
		m.ResetPrice()
		return nil
	}
	return fmt.Errorf("unknown ObjectStorage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ObjectStorageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.panierObjectStorage != nil {
		edges = append(edges, objectstorage.EdgePanierObjectStorage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ObjectStorageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case objectstorage.EdgePanierObjectStorage:
		ids := make([]ent.Value, 0, len(m.panierObjectStorage))
		for id := range m.panierObjectStorage {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ObjectStorageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpanierObjectStorage != nil {
		edges = append(edges, objectstorage.EdgePanierObjectStorage)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ObjectStorageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case objectstorage.EdgePanierObjectStorage:
		ids := make([]ent.Value, 0, len(m.removedpanierObjectStorage))
		for id := range m.removedpanierObjectStorage {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ObjectStorageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpanierObjectStorage {
		edges = append(edges, objectstorage.EdgePanierObjectStorage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ObjectStorageMutation) EdgeCleared(name string) bool {
	switch name {
	case objectstorage.EdgePanierObjectStorage:
		return m.clearedpanierObjectStorage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ObjectStorageMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ObjectStorage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ObjectStorageMutation) ResetEdge(name string) error {
	switch name {
	case objectstorage.EdgePanierObjectStorage:
		m.ResetPanierObjectStorage()
		return nil
	}
	return fmt.Errorf("unknown ObjectStorage edge %s", name)
}

// PanierMutation represents an operation that mutates the Panier nodes in the graph.
type PanierMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	uid                        *uuid.UUID
	clearedFields              map[string]struct{}
	panierInstances            map[int]struct{}
	removedpanierInstances     map[int]struct{}
	clearedpanierInstances     bool
	panierBlockStorage         map[int]struct{}
	removedpanierBlockStorage  map[int]struct{}
	clearedpanierBlockStorage  bool
	panierIPAddress            map[int]struct{}
	removedpanierIPAddress     map[int]struct{}
	clearedpanierIPAddress     bool
	panierLoadBalancer         map[int]struct{}
	removedpanierLoadBalancer  map[int]struct{}
	clearedpanierLoadBalancer  bool
	panierObjectStorage        map[int]struct{}
	removedpanierObjectStorage map[int]struct{}
	clearedpanierObjectStorage bool
	done                       bool
	oldValue                   func(context.Context) (*Panier, error)
	predicates                 []predicate.Panier
}

var _ ent.Mutation = (*PanierMutation)(nil)

// panierOption allows management of the mutation configuration using functional options.
type panierOption func(*PanierMutation)

// newPanierMutation creates new mutation for the Panier entity.
func newPanierMutation(c config, op Op, opts ...panierOption) *PanierMutation {
	m := &PanierMutation{
		config:        c,
		op:            op,
		typ:           TypePanier,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPanierID sets the ID field of the mutation.
func withPanierID(id int) panierOption {
	return func(m *PanierMutation) {
		var (
			err   error
			once  sync.Once
			value *Panier
		)
		m.oldValue = func(ctx context.Context) (*Panier, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Panier.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPanier sets the old Panier of the mutation.
func withPanier(node *Panier) panierOption {
	return func(m *PanierMutation) {
		m.oldValue = func(context.Context) (*Panier, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PanierMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PanierMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PanierMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PanierMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Panier.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *PanierMutation) SetUID(u uuid.UUID) {
	m.uid = &u
}

// UID returns the value of the "uid" field in the mutation.
func (m *PanierMutation) UID() (r uuid.UUID, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the Panier entity.
// If the Panier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PanierMutation) OldUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *PanierMutation) ResetUID() {
	m.uid = nil
}

// AddPanierInstanceIDs adds the "panierInstances" edge to the PanierInstances entity by ids.
func (m *PanierMutation) AddPanierInstanceIDs(ids ...int) {
	if m.panierInstances == nil {
		m.panierInstances = make(map[int]struct{})
	}
	for i := range ids {
		m.panierInstances[ids[i]] = struct{}{}
	}
}

// ClearPanierInstances clears the "panierInstances" edge to the PanierInstances entity.
func (m *PanierMutation) ClearPanierInstances() {
	m.clearedpanierInstances = true
}

// PanierInstancesCleared reports if the "panierInstances" edge to the PanierInstances entity was cleared.
func (m *PanierMutation) PanierInstancesCleared() bool {
	return m.clearedpanierInstances
}

// RemovePanierInstanceIDs removes the "panierInstances" edge to the PanierInstances entity by IDs.
func (m *PanierMutation) RemovePanierInstanceIDs(ids ...int) {
	if m.removedpanierInstances == nil {
		m.removedpanierInstances = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.panierInstances, ids[i])
		m.removedpanierInstances[ids[i]] = struct{}{}
	}
}

// RemovedPanierInstances returns the removed IDs of the "panierInstances" edge to the PanierInstances entity.
func (m *PanierMutation) RemovedPanierInstancesIDs() (ids []int) {
	for id := range m.removedpanierInstances {
		ids = append(ids, id)
	}
	return
}

// PanierInstancesIDs returns the "panierInstances" edge IDs in the mutation.
func (m *PanierMutation) PanierInstancesIDs() (ids []int) {
	for id := range m.panierInstances {
		ids = append(ids, id)
	}
	return
}

// ResetPanierInstances resets all changes to the "panierInstances" edge.
func (m *PanierMutation) ResetPanierInstances() {
	m.panierInstances = nil
	m.clearedpanierInstances = false
	m.removedpanierInstances = nil
}

// AddPanierBlockStorageIDs adds the "panierBlockStorage" edge to the PanierBlockStorage entity by ids.
func (m *PanierMutation) AddPanierBlockStorageIDs(ids ...int) {
	if m.panierBlockStorage == nil {
		m.panierBlockStorage = make(map[int]struct{})
	}
	for i := range ids {
		m.panierBlockStorage[ids[i]] = struct{}{}
	}
}

// ClearPanierBlockStorage clears the "panierBlockStorage" edge to the PanierBlockStorage entity.
func (m *PanierMutation) ClearPanierBlockStorage() {
	m.clearedpanierBlockStorage = true
}

// PanierBlockStorageCleared reports if the "panierBlockStorage" edge to the PanierBlockStorage entity was cleared.
func (m *PanierMutation) PanierBlockStorageCleared() bool {
	return m.clearedpanierBlockStorage
}

// RemovePanierBlockStorageIDs removes the "panierBlockStorage" edge to the PanierBlockStorage entity by IDs.
func (m *PanierMutation) RemovePanierBlockStorageIDs(ids ...int) {
	if m.removedpanierBlockStorage == nil {
		m.removedpanierBlockStorage = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.panierBlockStorage, ids[i])
		m.removedpanierBlockStorage[ids[i]] = struct{}{}
	}
}

// RemovedPanierBlockStorage returns the removed IDs of the "panierBlockStorage" edge to the PanierBlockStorage entity.
func (m *PanierMutation) RemovedPanierBlockStorageIDs() (ids []int) {
	for id := range m.removedpanierBlockStorage {
		ids = append(ids, id)
	}
	return
}

// PanierBlockStorageIDs returns the "panierBlockStorage" edge IDs in the mutation.
func (m *PanierMutation) PanierBlockStorageIDs() (ids []int) {
	for id := range m.panierBlockStorage {
		ids = append(ids, id)
	}
	return
}

// ResetPanierBlockStorage resets all changes to the "panierBlockStorage" edge.
func (m *PanierMutation) ResetPanierBlockStorage() {
	m.panierBlockStorage = nil
	m.clearedpanierBlockStorage = false
	m.removedpanierBlockStorage = nil
}

// AddPanierIPAddresIDs adds the "panierIPAddress" edge to the PanierIPAddress entity by ids.
func (m *PanierMutation) AddPanierIPAddresIDs(ids ...int) {
	if m.panierIPAddress == nil {
		m.panierIPAddress = make(map[int]struct{})
	}
	for i := range ids {
		m.panierIPAddress[ids[i]] = struct{}{}
	}
}

// ClearPanierIPAddress clears the "panierIPAddress" edge to the PanierIPAddress entity.
func (m *PanierMutation) ClearPanierIPAddress() {
	m.clearedpanierIPAddress = true
}

// PanierIPAddressCleared reports if the "panierIPAddress" edge to the PanierIPAddress entity was cleared.
func (m *PanierMutation) PanierIPAddressCleared() bool {
	return m.clearedpanierIPAddress
}

// RemovePanierIPAddresIDs removes the "panierIPAddress" edge to the PanierIPAddress entity by IDs.
func (m *PanierMutation) RemovePanierIPAddresIDs(ids ...int) {
	if m.removedpanierIPAddress == nil {
		m.removedpanierIPAddress = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.panierIPAddress, ids[i])
		m.removedpanierIPAddress[ids[i]] = struct{}{}
	}
}

// RemovedPanierIPAddress returns the removed IDs of the "panierIPAddress" edge to the PanierIPAddress entity.
func (m *PanierMutation) RemovedPanierIPAddressIDs() (ids []int) {
	for id := range m.removedpanierIPAddress {
		ids = append(ids, id)
	}
	return
}

// PanierIPAddressIDs returns the "panierIPAddress" edge IDs in the mutation.
func (m *PanierMutation) PanierIPAddressIDs() (ids []int) {
	for id := range m.panierIPAddress {
		ids = append(ids, id)
	}
	return
}

// ResetPanierIPAddress resets all changes to the "panierIPAddress" edge.
func (m *PanierMutation) ResetPanierIPAddress() {
	m.panierIPAddress = nil
	m.clearedpanierIPAddress = false
	m.removedpanierIPAddress = nil
}

// AddPanierLoadBalancerIDs adds the "panierLoadBalancer" edge to the PanierLoadBalancer entity by ids.
func (m *PanierMutation) AddPanierLoadBalancerIDs(ids ...int) {
	if m.panierLoadBalancer == nil {
		m.panierLoadBalancer = make(map[int]struct{})
	}
	for i := range ids {
		m.panierLoadBalancer[ids[i]] = struct{}{}
	}
}

// ClearPanierLoadBalancer clears the "panierLoadBalancer" edge to the PanierLoadBalancer entity.
func (m *PanierMutation) ClearPanierLoadBalancer() {
	m.clearedpanierLoadBalancer = true
}

// PanierLoadBalancerCleared reports if the "panierLoadBalancer" edge to the PanierLoadBalancer entity was cleared.
func (m *PanierMutation) PanierLoadBalancerCleared() bool {
	return m.clearedpanierLoadBalancer
}

// RemovePanierLoadBalancerIDs removes the "panierLoadBalancer" edge to the PanierLoadBalancer entity by IDs.
func (m *PanierMutation) RemovePanierLoadBalancerIDs(ids ...int) {
	if m.removedpanierLoadBalancer == nil {
		m.removedpanierLoadBalancer = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.panierLoadBalancer, ids[i])
		m.removedpanierLoadBalancer[ids[i]] = struct{}{}
	}
}

// RemovedPanierLoadBalancer returns the removed IDs of the "panierLoadBalancer" edge to the PanierLoadBalancer entity.
func (m *PanierMutation) RemovedPanierLoadBalancerIDs() (ids []int) {
	for id := range m.removedpanierLoadBalancer {
		ids = append(ids, id)
	}
	return
}

// PanierLoadBalancerIDs returns the "panierLoadBalancer" edge IDs in the mutation.
func (m *PanierMutation) PanierLoadBalancerIDs() (ids []int) {
	for id := range m.panierLoadBalancer {
		ids = append(ids, id)
	}
	return
}

// ResetPanierLoadBalancer resets all changes to the "panierLoadBalancer" edge.
func (m *PanierMutation) ResetPanierLoadBalancer() {
	m.panierLoadBalancer = nil
	m.clearedpanierLoadBalancer = false
	m.removedpanierLoadBalancer = nil
}

// AddPanierObjectStorageIDs adds the "panierObjectStorage" edge to the PanierObjectStorage entity by ids.
func (m *PanierMutation) AddPanierObjectStorageIDs(ids ...int) {
	if m.panierObjectStorage == nil {
		m.panierObjectStorage = make(map[int]struct{})
	}
	for i := range ids {
		m.panierObjectStorage[ids[i]] = struct{}{}
	}
}

// ClearPanierObjectStorage clears the "panierObjectStorage" edge to the PanierObjectStorage entity.
func (m *PanierMutation) ClearPanierObjectStorage() {
	m.clearedpanierObjectStorage = true
}

// PanierObjectStorageCleared reports if the "panierObjectStorage" edge to the PanierObjectStorage entity was cleared.
func (m *PanierMutation) PanierObjectStorageCleared() bool {
	return m.clearedpanierObjectStorage
}

// RemovePanierObjectStorageIDs removes the "panierObjectStorage" edge to the PanierObjectStorage entity by IDs.
func (m *PanierMutation) RemovePanierObjectStorageIDs(ids ...int) {
	if m.removedpanierObjectStorage == nil {
		m.removedpanierObjectStorage = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.panierObjectStorage, ids[i])
		m.removedpanierObjectStorage[ids[i]] = struct{}{}
	}
}

// RemovedPanierObjectStorage returns the removed IDs of the "panierObjectStorage" edge to the PanierObjectStorage entity.
func (m *PanierMutation) RemovedPanierObjectStorageIDs() (ids []int) {
	for id := range m.removedpanierObjectStorage {
		ids = append(ids, id)
	}
	return
}

// PanierObjectStorageIDs returns the "panierObjectStorage" edge IDs in the mutation.
func (m *PanierMutation) PanierObjectStorageIDs() (ids []int) {
	for id := range m.panierObjectStorage {
		ids = append(ids, id)
	}
	return
}

// ResetPanierObjectStorage resets all changes to the "panierObjectStorage" edge.
func (m *PanierMutation) ResetPanierObjectStorage() {
	m.panierObjectStorage = nil
	m.clearedpanierObjectStorage = false
	m.removedpanierObjectStorage = nil
}

// Where appends a list predicates to the PanierMutation builder.
func (m *PanierMutation) Where(ps ...predicate.Panier) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PanierMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PanierMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Panier, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PanierMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PanierMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Panier).
func (m *PanierMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PanierMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.uid != nil {
		fields = append(fields, panier.FieldUID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PanierMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case panier.FieldUID:
		return m.UID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PanierMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case panier.FieldUID:
		return m.OldUID(ctx)
	}
	return nil, fmt.Errorf("unknown Panier field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PanierMutation) SetField(name string, value ent.Value) error {
	switch name {
	case panier.FieldUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	}
	return fmt.Errorf("unknown Panier field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PanierMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PanierMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PanierMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Panier numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PanierMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PanierMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PanierMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Panier nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PanierMutation) ResetField(name string) error {
	switch name {
	case panier.FieldUID:
		m.ResetUID()
		return nil
	}
	return fmt.Errorf("unknown Panier field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PanierMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.panierInstances != nil {
		edges = append(edges, panier.EdgePanierInstances)
	}
	if m.panierBlockStorage != nil {
		edges = append(edges, panier.EdgePanierBlockStorage)
	}
	if m.panierIPAddress != nil {
		edges = append(edges, panier.EdgePanierIPAddress)
	}
	if m.panierLoadBalancer != nil {
		edges = append(edges, panier.EdgePanierLoadBalancer)
	}
	if m.panierObjectStorage != nil {
		edges = append(edges, panier.EdgePanierObjectStorage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PanierMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case panier.EdgePanierInstances:
		ids := make([]ent.Value, 0, len(m.panierInstances))
		for id := range m.panierInstances {
			ids = append(ids, id)
		}
		return ids
	case panier.EdgePanierBlockStorage:
		ids := make([]ent.Value, 0, len(m.panierBlockStorage))
		for id := range m.panierBlockStorage {
			ids = append(ids, id)
		}
		return ids
	case panier.EdgePanierIPAddress:
		ids := make([]ent.Value, 0, len(m.panierIPAddress))
		for id := range m.panierIPAddress {
			ids = append(ids, id)
		}
		return ids
	case panier.EdgePanierLoadBalancer:
		ids := make([]ent.Value, 0, len(m.panierLoadBalancer))
		for id := range m.panierLoadBalancer {
			ids = append(ids, id)
		}
		return ids
	case panier.EdgePanierObjectStorage:
		ids := make([]ent.Value, 0, len(m.panierObjectStorage))
		for id := range m.panierObjectStorage {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PanierMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedpanierInstances != nil {
		edges = append(edges, panier.EdgePanierInstances)
	}
	if m.removedpanierBlockStorage != nil {
		edges = append(edges, panier.EdgePanierBlockStorage)
	}
	if m.removedpanierIPAddress != nil {
		edges = append(edges, panier.EdgePanierIPAddress)
	}
	if m.removedpanierLoadBalancer != nil {
		edges = append(edges, panier.EdgePanierLoadBalancer)
	}
	if m.removedpanierObjectStorage != nil {
		edges = append(edges, panier.EdgePanierObjectStorage)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PanierMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case panier.EdgePanierInstances:
		ids := make([]ent.Value, 0, len(m.removedpanierInstances))
		for id := range m.removedpanierInstances {
			ids = append(ids, id)
		}
		return ids
	case panier.EdgePanierBlockStorage:
		ids := make([]ent.Value, 0, len(m.removedpanierBlockStorage))
		for id := range m.removedpanierBlockStorage {
			ids = append(ids, id)
		}
		return ids
	case panier.EdgePanierIPAddress:
		ids := make([]ent.Value, 0, len(m.removedpanierIPAddress))
		for id := range m.removedpanierIPAddress {
			ids = append(ids, id)
		}
		return ids
	case panier.EdgePanierLoadBalancer:
		ids := make([]ent.Value, 0, len(m.removedpanierLoadBalancer))
		for id := range m.removedpanierLoadBalancer {
			ids = append(ids, id)
		}
		return ids
	case panier.EdgePanierObjectStorage:
		ids := make([]ent.Value, 0, len(m.removedpanierObjectStorage))
		for id := range m.removedpanierObjectStorage {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PanierMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedpanierInstances {
		edges = append(edges, panier.EdgePanierInstances)
	}
	if m.clearedpanierBlockStorage {
		edges = append(edges, panier.EdgePanierBlockStorage)
	}
	if m.clearedpanierIPAddress {
		edges = append(edges, panier.EdgePanierIPAddress)
	}
	if m.clearedpanierLoadBalancer {
		edges = append(edges, panier.EdgePanierLoadBalancer)
	}
	if m.clearedpanierObjectStorage {
		edges = append(edges, panier.EdgePanierObjectStorage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PanierMutation) EdgeCleared(name string) bool {
	switch name {
	case panier.EdgePanierInstances:
		return m.clearedpanierInstances
	case panier.EdgePanierBlockStorage:
		return m.clearedpanierBlockStorage
	case panier.EdgePanierIPAddress:
		return m.clearedpanierIPAddress
	case panier.EdgePanierLoadBalancer:
		return m.clearedpanierLoadBalancer
	case panier.EdgePanierObjectStorage:
		return m.clearedpanierObjectStorage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PanierMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Panier unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PanierMutation) ResetEdge(name string) error {
	switch name {
	case panier.EdgePanierInstances:
		m.ResetPanierInstances()
		return nil
	case panier.EdgePanierBlockStorage:
		m.ResetPanierBlockStorage()
		return nil
	case panier.EdgePanierIPAddress:
		m.ResetPanierIPAddress()
		return nil
	case panier.EdgePanierLoadBalancer:
		m.ResetPanierLoadBalancer()
		return nil
	case panier.EdgePanierObjectStorage:
		m.ResetPanierObjectStorage()
		return nil
	}
	return fmt.Errorf("unknown Panier edge %s", name)
}

// PanierBlockStorageMutation represents an operation that mutates the PanierBlockStorage nodes in the graph.
type PanierBlockStorageMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	quantity            *int
	addquantity         *int
	clearedFields       map[string]struct{}
	panier              *int
	clearedpanier       bool
	blockStorage        *int
	clearedblockStorage bool
	done                bool
	oldValue            func(context.Context) (*PanierBlockStorage, error)
	predicates          []predicate.PanierBlockStorage
}

var _ ent.Mutation = (*PanierBlockStorageMutation)(nil)

// panierblockstorageOption allows management of the mutation configuration using functional options.
type panierblockstorageOption func(*PanierBlockStorageMutation)

// newPanierBlockStorageMutation creates new mutation for the PanierBlockStorage entity.
func newPanierBlockStorageMutation(c config, op Op, opts ...panierblockstorageOption) *PanierBlockStorageMutation {
	m := &PanierBlockStorageMutation{
		config:        c,
		op:            op,
		typ:           TypePanierBlockStorage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPanierBlockStorageID sets the ID field of the mutation.
func withPanierBlockStorageID(id int) panierblockstorageOption {
	return func(m *PanierBlockStorageMutation) {
		var (
			err   error
			once  sync.Once
			value *PanierBlockStorage
		)
		m.oldValue = func(ctx context.Context) (*PanierBlockStorage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PanierBlockStorage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPanierBlockStorage sets the old PanierBlockStorage of the mutation.
func withPanierBlockStorage(node *PanierBlockStorage) panierblockstorageOption {
	return func(m *PanierBlockStorageMutation) {
		m.oldValue = func(context.Context) (*PanierBlockStorage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PanierBlockStorageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PanierBlockStorageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PanierBlockStorageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PanierBlockStorageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PanierBlockStorage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuantity sets the "quantity" field.
func (m *PanierBlockStorageMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *PanierBlockStorageMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the PanierBlockStorage entity.
// If the PanierBlockStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PanierBlockStorageMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *PanierBlockStorageMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *PanierBlockStorageMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *PanierBlockStorageMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetPanierID sets the "panier" edge to the Panier entity by id.
func (m *PanierBlockStorageMutation) SetPanierID(id int) {
	m.panier = &id
}

// ClearPanier clears the "panier" edge to the Panier entity.
func (m *PanierBlockStorageMutation) ClearPanier() {
	m.clearedpanier = true
}

// PanierCleared reports if the "panier" edge to the Panier entity was cleared.
func (m *PanierBlockStorageMutation) PanierCleared() bool {
	return m.clearedpanier
}

// PanierID returns the "panier" edge ID in the mutation.
func (m *PanierBlockStorageMutation) PanierID() (id int, exists bool) {
	if m.panier != nil {
		return *m.panier, true
	}
	return
}

// PanierIDs returns the "panier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PanierID instead. It exists only for internal usage by the builders.
func (m *PanierBlockStorageMutation) PanierIDs() (ids []int) {
	if id := m.panier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPanier resets all changes to the "panier" edge.
func (m *PanierBlockStorageMutation) ResetPanier() {
	m.panier = nil
	m.clearedpanier = false
}

// SetBlockStorageID sets the "blockStorage" edge to the BlockStorage entity by id.
func (m *PanierBlockStorageMutation) SetBlockStorageID(id int) {
	m.blockStorage = &id
}

// ClearBlockStorage clears the "blockStorage" edge to the BlockStorage entity.
func (m *PanierBlockStorageMutation) ClearBlockStorage() {
	m.clearedblockStorage = true
}

// BlockStorageCleared reports if the "blockStorage" edge to the BlockStorage entity was cleared.
func (m *PanierBlockStorageMutation) BlockStorageCleared() bool {
	return m.clearedblockStorage
}

// BlockStorageID returns the "blockStorage" edge ID in the mutation.
func (m *PanierBlockStorageMutation) BlockStorageID() (id int, exists bool) {
	if m.blockStorage != nil {
		return *m.blockStorage, true
	}
	return
}

// BlockStorageIDs returns the "blockStorage" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockStorageID instead. It exists only for internal usage by the builders.
func (m *PanierBlockStorageMutation) BlockStorageIDs() (ids []int) {
	if id := m.blockStorage; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockStorage resets all changes to the "blockStorage" edge.
func (m *PanierBlockStorageMutation) ResetBlockStorage() {
	m.blockStorage = nil
	m.clearedblockStorage = false
}

// Where appends a list predicates to the PanierBlockStorageMutation builder.
func (m *PanierBlockStorageMutation) Where(ps ...predicate.PanierBlockStorage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PanierBlockStorageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PanierBlockStorageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PanierBlockStorage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PanierBlockStorageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PanierBlockStorageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PanierBlockStorage).
func (m *PanierBlockStorageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PanierBlockStorageMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.quantity != nil {
		fields = append(fields, panierblockstorage.FieldQuantity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PanierBlockStorageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case panierblockstorage.FieldQuantity:
		return m.Quantity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PanierBlockStorageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case panierblockstorage.FieldQuantity:
		return m.OldQuantity(ctx)
	}
	return nil, fmt.Errorf("unknown PanierBlockStorage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PanierBlockStorageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case panierblockstorage.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown PanierBlockStorage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PanierBlockStorageMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, panierblockstorage.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PanierBlockStorageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case panierblockstorage.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PanierBlockStorageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case panierblockstorage.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown PanierBlockStorage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PanierBlockStorageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PanierBlockStorageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PanierBlockStorageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PanierBlockStorage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PanierBlockStorageMutation) ResetField(name string) error {
	switch name {
	case panierblockstorage.FieldQuantity:
		m.ResetQuantity()
		return nil
	}
	return fmt.Errorf("unknown PanierBlockStorage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PanierBlockStorageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.panier != nil {
		edges = append(edges, panierblockstorage.EdgePanier)
	}
	if m.blockStorage != nil {
		edges = append(edges, panierblockstorage.EdgeBlockStorage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PanierBlockStorageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case panierblockstorage.EdgePanier:
		if id := m.panier; id != nil {
			return []ent.Value{*id}
		}
	case panierblockstorage.EdgeBlockStorage:
		if id := m.blockStorage; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PanierBlockStorageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PanierBlockStorageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PanierBlockStorageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpanier {
		edges = append(edges, panierblockstorage.EdgePanier)
	}
	if m.clearedblockStorage {
		edges = append(edges, panierblockstorage.EdgeBlockStorage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PanierBlockStorageMutation) EdgeCleared(name string) bool {
	switch name {
	case panierblockstorage.EdgePanier:
		return m.clearedpanier
	case panierblockstorage.EdgeBlockStorage:
		return m.clearedblockStorage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PanierBlockStorageMutation) ClearEdge(name string) error {
	switch name {
	case panierblockstorage.EdgePanier:
		m.ClearPanier()
		return nil
	case panierblockstorage.EdgeBlockStorage:
		m.ClearBlockStorage()
		return nil
	}
	return fmt.Errorf("unknown PanierBlockStorage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PanierBlockStorageMutation) ResetEdge(name string) error {
	switch name {
	case panierblockstorage.EdgePanier:
		m.ResetPanier()
		return nil
	case panierblockstorage.EdgeBlockStorage:
		m.ResetBlockStorage()
		return nil
	}
	return fmt.Errorf("unknown PanierBlockStorage edge %s", name)
}

// PanierIPAddressMutation represents an operation that mutates the PanierIPAddress nodes in the graph.
type PanierIPAddressMutation struct {
	config
	op                Op
	typ               string
	id                *int
	quantity          *int
	addquantity       *int
	clearedFields     map[string]struct{}
	panier            *int
	clearedpanier     bool
	_IPAddress        *int
	cleared_IPAddress bool
	done              bool
	oldValue          func(context.Context) (*PanierIPAddress, error)
	predicates        []predicate.PanierIPAddress
}

var _ ent.Mutation = (*PanierIPAddressMutation)(nil)

// panieripaddressOption allows management of the mutation configuration using functional options.
type panieripaddressOption func(*PanierIPAddressMutation)

// newPanierIPAddressMutation creates new mutation for the PanierIPAddress entity.
func newPanierIPAddressMutation(c config, op Op, opts ...panieripaddressOption) *PanierIPAddressMutation {
	m := &PanierIPAddressMutation{
		config:        c,
		op:            op,
		typ:           TypePanierIPAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPanierIPAddressID sets the ID field of the mutation.
func withPanierIPAddressID(id int) panieripaddressOption {
	return func(m *PanierIPAddressMutation) {
		var (
			err   error
			once  sync.Once
			value *PanierIPAddress
		)
		m.oldValue = func(ctx context.Context) (*PanierIPAddress, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PanierIPAddress.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPanierIPAddress sets the old PanierIPAddress of the mutation.
func withPanierIPAddress(node *PanierIPAddress) panieripaddressOption {
	return func(m *PanierIPAddressMutation) {
		m.oldValue = func(context.Context) (*PanierIPAddress, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PanierIPAddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PanierIPAddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PanierIPAddressMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PanierIPAddressMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PanierIPAddress.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuantity sets the "quantity" field.
func (m *PanierIPAddressMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *PanierIPAddressMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the PanierIPAddress entity.
// If the PanierIPAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PanierIPAddressMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *PanierIPAddressMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *PanierIPAddressMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *PanierIPAddressMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetPanierID sets the "panier" edge to the Panier entity by id.
func (m *PanierIPAddressMutation) SetPanierID(id int) {
	m.panier = &id
}

// ClearPanier clears the "panier" edge to the Panier entity.
func (m *PanierIPAddressMutation) ClearPanier() {
	m.clearedpanier = true
}

// PanierCleared reports if the "panier" edge to the Panier entity was cleared.
func (m *PanierIPAddressMutation) PanierCleared() bool {
	return m.clearedpanier
}

// PanierID returns the "panier" edge ID in the mutation.
func (m *PanierIPAddressMutation) PanierID() (id int, exists bool) {
	if m.panier != nil {
		return *m.panier, true
	}
	return
}

// PanierIDs returns the "panier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PanierID instead. It exists only for internal usage by the builders.
func (m *PanierIPAddressMutation) PanierIDs() (ids []int) {
	if id := m.panier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPanier resets all changes to the "panier" edge.
func (m *PanierIPAddressMutation) ResetPanier() {
	m.panier = nil
	m.clearedpanier = false
}

// SetIPAddressID sets the "IPAddress" edge to the IPAddress entity by id.
func (m *PanierIPAddressMutation) SetIPAddressID(id int) {
	m._IPAddress = &id
}

// ClearIPAddress clears the "IPAddress" edge to the IPAddress entity.
func (m *PanierIPAddressMutation) ClearIPAddress() {
	m.cleared_IPAddress = true
}

// IPAddressCleared reports if the "IPAddress" edge to the IPAddress entity was cleared.
func (m *PanierIPAddressMutation) IPAddressCleared() bool {
	return m.cleared_IPAddress
}

// IPAddressID returns the "IPAddress" edge ID in the mutation.
func (m *PanierIPAddressMutation) IPAddressID() (id int, exists bool) {
	if m._IPAddress != nil {
		return *m._IPAddress, true
	}
	return
}

// IPAddressIDs returns the "IPAddress" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IPAddressID instead. It exists only for internal usage by the builders.
func (m *PanierIPAddressMutation) IPAddressIDs() (ids []int) {
	if id := m._IPAddress; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIPAddress resets all changes to the "IPAddress" edge.
func (m *PanierIPAddressMutation) ResetIPAddress() {
	m._IPAddress = nil
	m.cleared_IPAddress = false
}

// Where appends a list predicates to the PanierIPAddressMutation builder.
func (m *PanierIPAddressMutation) Where(ps ...predicate.PanierIPAddress) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PanierIPAddressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PanierIPAddressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PanierIPAddress, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PanierIPAddressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PanierIPAddressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PanierIPAddress).
func (m *PanierIPAddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PanierIPAddressMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.quantity != nil {
		fields = append(fields, panieripaddress.FieldQuantity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PanierIPAddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case panieripaddress.FieldQuantity:
		return m.Quantity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PanierIPAddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case panieripaddress.FieldQuantity:
		return m.OldQuantity(ctx)
	}
	return nil, fmt.Errorf("unknown PanierIPAddress field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PanierIPAddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case panieripaddress.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown PanierIPAddress field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PanierIPAddressMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, panieripaddress.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PanierIPAddressMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case panieripaddress.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PanierIPAddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	case panieripaddress.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown PanierIPAddress numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PanierIPAddressMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PanierIPAddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PanierIPAddressMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PanierIPAddress nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PanierIPAddressMutation) ResetField(name string) error {
	switch name {
	case panieripaddress.FieldQuantity:
		m.ResetQuantity()
		return nil
	}
	return fmt.Errorf("unknown PanierIPAddress field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PanierIPAddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.panier != nil {
		edges = append(edges, panieripaddress.EdgePanier)
	}
	if m._IPAddress != nil {
		edges = append(edges, panieripaddress.EdgeIPAddress)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PanierIPAddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case panieripaddress.EdgePanier:
		if id := m.panier; id != nil {
			return []ent.Value{*id}
		}
	case panieripaddress.EdgeIPAddress:
		if id := m._IPAddress; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PanierIPAddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PanierIPAddressMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PanierIPAddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpanier {
		edges = append(edges, panieripaddress.EdgePanier)
	}
	if m.cleared_IPAddress {
		edges = append(edges, panieripaddress.EdgeIPAddress)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PanierIPAddressMutation) EdgeCleared(name string) bool {
	switch name {
	case panieripaddress.EdgePanier:
		return m.clearedpanier
	case panieripaddress.EdgeIPAddress:
		return m.cleared_IPAddress
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PanierIPAddressMutation) ClearEdge(name string) error {
	switch name {
	case panieripaddress.EdgePanier:
		m.ClearPanier()
		return nil
	case panieripaddress.EdgeIPAddress:
		m.ClearIPAddress()
		return nil
	}
	return fmt.Errorf("unknown PanierIPAddress unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PanierIPAddressMutation) ResetEdge(name string) error {
	switch name {
	case panieripaddress.EdgePanier:
		m.ResetPanier()
		return nil
	case panieripaddress.EdgeIPAddress:
		m.ResetIPAddress()
		return nil
	}
	return fmt.Errorf("unknown PanierIPAddress edge %s", name)
}

// PanierInstancesMutation represents an operation that mutates the PanierInstances nodes in the graph.
type PanierInstancesMutation struct {
	config
	op              Op
	typ             string
	id              *int
	quantity        *int
	addquantity     *int
	clearedFields   map[string]struct{}
	panier          *int
	clearedpanier   bool
	instance        *int
	clearedinstance bool
	done            bool
	oldValue        func(context.Context) (*PanierInstances, error)
	predicates      []predicate.PanierInstances
}

var _ ent.Mutation = (*PanierInstancesMutation)(nil)

// panierinstancesOption allows management of the mutation configuration using functional options.
type panierinstancesOption func(*PanierInstancesMutation)

// newPanierInstancesMutation creates new mutation for the PanierInstances entity.
func newPanierInstancesMutation(c config, op Op, opts ...panierinstancesOption) *PanierInstancesMutation {
	m := &PanierInstancesMutation{
		config:        c,
		op:            op,
		typ:           TypePanierInstances,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPanierInstancesID sets the ID field of the mutation.
func withPanierInstancesID(id int) panierinstancesOption {
	return func(m *PanierInstancesMutation) {
		var (
			err   error
			once  sync.Once
			value *PanierInstances
		)
		m.oldValue = func(ctx context.Context) (*PanierInstances, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PanierInstances.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPanierInstances sets the old PanierInstances of the mutation.
func withPanierInstances(node *PanierInstances) panierinstancesOption {
	return func(m *PanierInstancesMutation) {
		m.oldValue = func(context.Context) (*PanierInstances, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PanierInstancesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PanierInstancesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PanierInstancesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PanierInstancesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PanierInstances.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuantity sets the "quantity" field.
func (m *PanierInstancesMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *PanierInstancesMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the PanierInstances entity.
// If the PanierInstances object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PanierInstancesMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *PanierInstancesMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *PanierInstancesMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *PanierInstancesMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetPanierID sets the "panier" edge to the Panier entity by id.
func (m *PanierInstancesMutation) SetPanierID(id int) {
	m.panier = &id
}

// ClearPanier clears the "panier" edge to the Panier entity.
func (m *PanierInstancesMutation) ClearPanier() {
	m.clearedpanier = true
}

// PanierCleared reports if the "panier" edge to the Panier entity was cleared.
func (m *PanierInstancesMutation) PanierCleared() bool {
	return m.clearedpanier
}

// PanierID returns the "panier" edge ID in the mutation.
func (m *PanierInstancesMutation) PanierID() (id int, exists bool) {
	if m.panier != nil {
		return *m.panier, true
	}
	return
}

// PanierIDs returns the "panier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PanierID instead. It exists only for internal usage by the builders.
func (m *PanierInstancesMutation) PanierIDs() (ids []int) {
	if id := m.panier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPanier resets all changes to the "panier" edge.
func (m *PanierInstancesMutation) ResetPanier() {
	m.panier = nil
	m.clearedpanier = false
}

// SetInstanceID sets the "instance" edge to the Instances entity by id.
func (m *PanierInstancesMutation) SetInstanceID(id int) {
	m.instance = &id
}

// ClearInstance clears the "instance" edge to the Instances entity.
func (m *PanierInstancesMutation) ClearInstance() {
	m.clearedinstance = true
}

// InstanceCleared reports if the "instance" edge to the Instances entity was cleared.
func (m *PanierInstancesMutation) InstanceCleared() bool {
	return m.clearedinstance
}

// InstanceID returns the "instance" edge ID in the mutation.
func (m *PanierInstancesMutation) InstanceID() (id int, exists bool) {
	if m.instance != nil {
		return *m.instance, true
	}
	return
}

// InstanceIDs returns the "instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstanceID instead. It exists only for internal usage by the builders.
func (m *PanierInstancesMutation) InstanceIDs() (ids []int) {
	if id := m.instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstance resets all changes to the "instance" edge.
func (m *PanierInstancesMutation) ResetInstance() {
	m.instance = nil
	m.clearedinstance = false
}

// Where appends a list predicates to the PanierInstancesMutation builder.
func (m *PanierInstancesMutation) Where(ps ...predicate.PanierInstances) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PanierInstancesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PanierInstancesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PanierInstances, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PanierInstancesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PanierInstancesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PanierInstances).
func (m *PanierInstancesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PanierInstancesMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.quantity != nil {
		fields = append(fields, panierinstances.FieldQuantity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PanierInstancesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case panierinstances.FieldQuantity:
		return m.Quantity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PanierInstancesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case panierinstances.FieldQuantity:
		return m.OldQuantity(ctx)
	}
	return nil, fmt.Errorf("unknown PanierInstances field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PanierInstancesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case panierinstances.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown PanierInstances field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PanierInstancesMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, panierinstances.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PanierInstancesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case panierinstances.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PanierInstancesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case panierinstances.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown PanierInstances numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PanierInstancesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PanierInstancesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PanierInstancesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PanierInstances nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PanierInstancesMutation) ResetField(name string) error {
	switch name {
	case panierinstances.FieldQuantity:
		m.ResetQuantity()
		return nil
	}
	return fmt.Errorf("unknown PanierInstances field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PanierInstancesMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.panier != nil {
		edges = append(edges, panierinstances.EdgePanier)
	}
	if m.instance != nil {
		edges = append(edges, panierinstances.EdgeInstance)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PanierInstancesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case panierinstances.EdgePanier:
		if id := m.panier; id != nil {
			return []ent.Value{*id}
		}
	case panierinstances.EdgeInstance:
		if id := m.instance; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PanierInstancesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PanierInstancesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PanierInstancesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpanier {
		edges = append(edges, panierinstances.EdgePanier)
	}
	if m.clearedinstance {
		edges = append(edges, panierinstances.EdgeInstance)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PanierInstancesMutation) EdgeCleared(name string) bool {
	switch name {
	case panierinstances.EdgePanier:
		return m.clearedpanier
	case panierinstances.EdgeInstance:
		return m.clearedinstance
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PanierInstancesMutation) ClearEdge(name string) error {
	switch name {
	case panierinstances.EdgePanier:
		m.ClearPanier()
		return nil
	case panierinstances.EdgeInstance:
		m.ClearInstance()
		return nil
	}
	return fmt.Errorf("unknown PanierInstances unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PanierInstancesMutation) ResetEdge(name string) error {
	switch name {
	case panierinstances.EdgePanier:
		m.ResetPanier()
		return nil
	case panierinstances.EdgeInstance:
		m.ResetInstance()
		return nil
	}
	return fmt.Errorf("unknown PanierInstances edge %s", name)
}

// PanierLoadBalancerMutation represents an operation that mutates the PanierLoadBalancer nodes in the graph.
type PanierLoadBalancerMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	quantity            *int
	addquantity         *int
	clearedFields       map[string]struct{}
	panier              *int
	clearedpanier       bool
	loadBalancer        *int
	clearedloadBalancer bool
	done                bool
	oldValue            func(context.Context) (*PanierLoadBalancer, error)
	predicates          []predicate.PanierLoadBalancer
}

var _ ent.Mutation = (*PanierLoadBalancerMutation)(nil)

// panierloadbalancerOption allows management of the mutation configuration using functional options.
type panierloadbalancerOption func(*PanierLoadBalancerMutation)

// newPanierLoadBalancerMutation creates new mutation for the PanierLoadBalancer entity.
func newPanierLoadBalancerMutation(c config, op Op, opts ...panierloadbalancerOption) *PanierLoadBalancerMutation {
	m := &PanierLoadBalancerMutation{
		config:        c,
		op:            op,
		typ:           TypePanierLoadBalancer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPanierLoadBalancerID sets the ID field of the mutation.
func withPanierLoadBalancerID(id int) panierloadbalancerOption {
	return func(m *PanierLoadBalancerMutation) {
		var (
			err   error
			once  sync.Once
			value *PanierLoadBalancer
		)
		m.oldValue = func(ctx context.Context) (*PanierLoadBalancer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PanierLoadBalancer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPanierLoadBalancer sets the old PanierLoadBalancer of the mutation.
func withPanierLoadBalancer(node *PanierLoadBalancer) panierloadbalancerOption {
	return func(m *PanierLoadBalancerMutation) {
		m.oldValue = func(context.Context) (*PanierLoadBalancer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PanierLoadBalancerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PanierLoadBalancerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PanierLoadBalancerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PanierLoadBalancerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PanierLoadBalancer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuantity sets the "quantity" field.
func (m *PanierLoadBalancerMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *PanierLoadBalancerMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the PanierLoadBalancer entity.
// If the PanierLoadBalancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PanierLoadBalancerMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *PanierLoadBalancerMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *PanierLoadBalancerMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *PanierLoadBalancerMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetPanierID sets the "panier" edge to the Panier entity by id.
func (m *PanierLoadBalancerMutation) SetPanierID(id int) {
	m.panier = &id
}

// ClearPanier clears the "panier" edge to the Panier entity.
func (m *PanierLoadBalancerMutation) ClearPanier() {
	m.clearedpanier = true
}

// PanierCleared reports if the "panier" edge to the Panier entity was cleared.
func (m *PanierLoadBalancerMutation) PanierCleared() bool {
	return m.clearedpanier
}

// PanierID returns the "panier" edge ID in the mutation.
func (m *PanierLoadBalancerMutation) PanierID() (id int, exists bool) {
	if m.panier != nil {
		return *m.panier, true
	}
	return
}

// PanierIDs returns the "panier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PanierID instead. It exists only for internal usage by the builders.
func (m *PanierLoadBalancerMutation) PanierIDs() (ids []int) {
	if id := m.panier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPanier resets all changes to the "panier" edge.
func (m *PanierLoadBalancerMutation) ResetPanier() {
	m.panier = nil
	m.clearedpanier = false
}

// SetLoadBalancerID sets the "loadBalancer" edge to the LoadBalancer entity by id.
func (m *PanierLoadBalancerMutation) SetLoadBalancerID(id int) {
	m.loadBalancer = &id
}

// ClearLoadBalancer clears the "loadBalancer" edge to the LoadBalancer entity.
func (m *PanierLoadBalancerMutation) ClearLoadBalancer() {
	m.clearedloadBalancer = true
}

// LoadBalancerCleared reports if the "loadBalancer" edge to the LoadBalancer entity was cleared.
func (m *PanierLoadBalancerMutation) LoadBalancerCleared() bool {
	return m.clearedloadBalancer
}

// LoadBalancerID returns the "loadBalancer" edge ID in the mutation.
func (m *PanierLoadBalancerMutation) LoadBalancerID() (id int, exists bool) {
	if m.loadBalancer != nil {
		return *m.loadBalancer, true
	}
	return
}

// LoadBalancerIDs returns the "loadBalancer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LoadBalancerID instead. It exists only for internal usage by the builders.
func (m *PanierLoadBalancerMutation) LoadBalancerIDs() (ids []int) {
	if id := m.loadBalancer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLoadBalancer resets all changes to the "loadBalancer" edge.
func (m *PanierLoadBalancerMutation) ResetLoadBalancer() {
	m.loadBalancer = nil
	m.clearedloadBalancer = false
}

// Where appends a list predicates to the PanierLoadBalancerMutation builder.
func (m *PanierLoadBalancerMutation) Where(ps ...predicate.PanierLoadBalancer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PanierLoadBalancerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PanierLoadBalancerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PanierLoadBalancer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PanierLoadBalancerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PanierLoadBalancerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PanierLoadBalancer).
func (m *PanierLoadBalancerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PanierLoadBalancerMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.quantity != nil {
		fields = append(fields, panierloadbalancer.FieldQuantity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PanierLoadBalancerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case panierloadbalancer.FieldQuantity:
		return m.Quantity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PanierLoadBalancerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case panierloadbalancer.FieldQuantity:
		return m.OldQuantity(ctx)
	}
	return nil, fmt.Errorf("unknown PanierLoadBalancer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PanierLoadBalancerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case panierloadbalancer.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown PanierLoadBalancer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PanierLoadBalancerMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, panierloadbalancer.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PanierLoadBalancerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case panierloadbalancer.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PanierLoadBalancerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case panierloadbalancer.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown PanierLoadBalancer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PanierLoadBalancerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PanierLoadBalancerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PanierLoadBalancerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PanierLoadBalancer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PanierLoadBalancerMutation) ResetField(name string) error {
	switch name {
	case panierloadbalancer.FieldQuantity:
		m.ResetQuantity()
		return nil
	}
	return fmt.Errorf("unknown PanierLoadBalancer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PanierLoadBalancerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.panier != nil {
		edges = append(edges, panierloadbalancer.EdgePanier)
	}
	if m.loadBalancer != nil {
		edges = append(edges, panierloadbalancer.EdgeLoadBalancer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PanierLoadBalancerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case panierloadbalancer.EdgePanier:
		if id := m.panier; id != nil {
			return []ent.Value{*id}
		}
	case panierloadbalancer.EdgeLoadBalancer:
		if id := m.loadBalancer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PanierLoadBalancerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PanierLoadBalancerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PanierLoadBalancerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpanier {
		edges = append(edges, panierloadbalancer.EdgePanier)
	}
	if m.clearedloadBalancer {
		edges = append(edges, panierloadbalancer.EdgeLoadBalancer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PanierLoadBalancerMutation) EdgeCleared(name string) bool {
	switch name {
	case panierloadbalancer.EdgePanier:
		return m.clearedpanier
	case panierloadbalancer.EdgeLoadBalancer:
		return m.clearedloadBalancer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PanierLoadBalancerMutation) ClearEdge(name string) error {
	switch name {
	case panierloadbalancer.EdgePanier:
		m.ClearPanier()
		return nil
	case panierloadbalancer.EdgeLoadBalancer:
		m.ClearLoadBalancer()
		return nil
	}
	return fmt.Errorf("unknown PanierLoadBalancer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PanierLoadBalancerMutation) ResetEdge(name string) error {
	switch name {
	case panierloadbalancer.EdgePanier:
		m.ResetPanier()
		return nil
	case panierloadbalancer.EdgeLoadBalancer:
		m.ResetLoadBalancer()
		return nil
	}
	return fmt.Errorf("unknown PanierLoadBalancer edge %s", name)
}

// PanierObjectStorageMutation represents an operation that mutates the PanierObjectStorage nodes in the graph.
type PanierObjectStorageMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	quantity             *int
	addquantity          *int
	clearedFields        map[string]struct{}
	panier               *int
	clearedpanier        bool
	objectStorage        *int
	clearedobjectStorage bool
	done                 bool
	oldValue             func(context.Context) (*PanierObjectStorage, error)
	predicates           []predicate.PanierObjectStorage
}

var _ ent.Mutation = (*PanierObjectStorageMutation)(nil)

// panierobjectstorageOption allows management of the mutation configuration using functional options.
type panierobjectstorageOption func(*PanierObjectStorageMutation)

// newPanierObjectStorageMutation creates new mutation for the PanierObjectStorage entity.
func newPanierObjectStorageMutation(c config, op Op, opts ...panierobjectstorageOption) *PanierObjectStorageMutation {
	m := &PanierObjectStorageMutation{
		config:        c,
		op:            op,
		typ:           TypePanierObjectStorage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPanierObjectStorageID sets the ID field of the mutation.
func withPanierObjectStorageID(id int) panierobjectstorageOption {
	return func(m *PanierObjectStorageMutation) {
		var (
			err   error
			once  sync.Once
			value *PanierObjectStorage
		)
		m.oldValue = func(ctx context.Context) (*PanierObjectStorage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PanierObjectStorage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPanierObjectStorage sets the old PanierObjectStorage of the mutation.
func withPanierObjectStorage(node *PanierObjectStorage) panierobjectstorageOption {
	return func(m *PanierObjectStorageMutation) {
		m.oldValue = func(context.Context) (*PanierObjectStorage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PanierObjectStorageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PanierObjectStorageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PanierObjectStorageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PanierObjectStorageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PanierObjectStorage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuantity sets the "quantity" field.
func (m *PanierObjectStorageMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *PanierObjectStorageMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the PanierObjectStorage entity.
// If the PanierObjectStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PanierObjectStorageMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *PanierObjectStorageMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *PanierObjectStorageMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *PanierObjectStorageMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetPanierID sets the "panier" edge to the Panier entity by id.
func (m *PanierObjectStorageMutation) SetPanierID(id int) {
	m.panier = &id
}

// ClearPanier clears the "panier" edge to the Panier entity.
func (m *PanierObjectStorageMutation) ClearPanier() {
	m.clearedpanier = true
}

// PanierCleared reports if the "panier" edge to the Panier entity was cleared.
func (m *PanierObjectStorageMutation) PanierCleared() bool {
	return m.clearedpanier
}

// PanierID returns the "panier" edge ID in the mutation.
func (m *PanierObjectStorageMutation) PanierID() (id int, exists bool) {
	if m.panier != nil {
		return *m.panier, true
	}
	return
}

// PanierIDs returns the "panier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PanierID instead. It exists only for internal usage by the builders.
func (m *PanierObjectStorageMutation) PanierIDs() (ids []int) {
	if id := m.panier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPanier resets all changes to the "panier" edge.
func (m *PanierObjectStorageMutation) ResetPanier() {
	m.panier = nil
	m.clearedpanier = false
}

// SetObjectStorageID sets the "objectStorage" edge to the ObjectStorage entity by id.
func (m *PanierObjectStorageMutation) SetObjectStorageID(id int) {
	m.objectStorage = &id
}

// ClearObjectStorage clears the "objectStorage" edge to the ObjectStorage entity.
func (m *PanierObjectStorageMutation) ClearObjectStorage() {
	m.clearedobjectStorage = true
}

// ObjectStorageCleared reports if the "objectStorage" edge to the ObjectStorage entity was cleared.
func (m *PanierObjectStorageMutation) ObjectStorageCleared() bool {
	return m.clearedobjectStorage
}

// ObjectStorageID returns the "objectStorage" edge ID in the mutation.
func (m *PanierObjectStorageMutation) ObjectStorageID() (id int, exists bool) {
	if m.objectStorage != nil {
		return *m.objectStorage, true
	}
	return
}

// ObjectStorageIDs returns the "objectStorage" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ObjectStorageID instead. It exists only for internal usage by the builders.
func (m *PanierObjectStorageMutation) ObjectStorageIDs() (ids []int) {
	if id := m.objectStorage; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetObjectStorage resets all changes to the "objectStorage" edge.
func (m *PanierObjectStorageMutation) ResetObjectStorage() {
	m.objectStorage = nil
	m.clearedobjectStorage = false
}

// Where appends a list predicates to the PanierObjectStorageMutation builder.
func (m *PanierObjectStorageMutation) Where(ps ...predicate.PanierObjectStorage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PanierObjectStorageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PanierObjectStorageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PanierObjectStorage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PanierObjectStorageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PanierObjectStorageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PanierObjectStorage).
func (m *PanierObjectStorageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PanierObjectStorageMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.quantity != nil {
		fields = append(fields, panierobjectstorage.FieldQuantity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PanierObjectStorageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case panierobjectstorage.FieldQuantity:
		return m.Quantity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PanierObjectStorageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case panierobjectstorage.FieldQuantity:
		return m.OldQuantity(ctx)
	}
	return nil, fmt.Errorf("unknown PanierObjectStorage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PanierObjectStorageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case panierobjectstorage.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown PanierObjectStorage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PanierObjectStorageMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, panierobjectstorage.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PanierObjectStorageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case panierobjectstorage.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PanierObjectStorageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case panierobjectstorage.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown PanierObjectStorage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PanierObjectStorageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PanierObjectStorageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PanierObjectStorageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PanierObjectStorage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PanierObjectStorageMutation) ResetField(name string) error {
	switch name {
	case panierobjectstorage.FieldQuantity:
		m.ResetQuantity()
		return nil
	}
	return fmt.Errorf("unknown PanierObjectStorage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PanierObjectStorageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.panier != nil {
		edges = append(edges, panierobjectstorage.EdgePanier)
	}
	if m.objectStorage != nil {
		edges = append(edges, panierobjectstorage.EdgeObjectStorage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PanierObjectStorageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case panierobjectstorage.EdgePanier:
		if id := m.panier; id != nil {
			return []ent.Value{*id}
		}
	case panierobjectstorage.EdgeObjectStorage:
		if id := m.objectStorage; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PanierObjectStorageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PanierObjectStorageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PanierObjectStorageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpanier {
		edges = append(edges, panierobjectstorage.EdgePanier)
	}
	if m.clearedobjectStorage {
		edges = append(edges, panierobjectstorage.EdgeObjectStorage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PanierObjectStorageMutation) EdgeCleared(name string) bool {
	switch name {
	case panierobjectstorage.EdgePanier:
		return m.clearedpanier
	case panierobjectstorage.EdgeObjectStorage:
		return m.clearedobjectStorage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PanierObjectStorageMutation) ClearEdge(name string) error {
	switch name {
	case panierobjectstorage.EdgePanier:
		m.ClearPanier()
		return nil
	case panierobjectstorage.EdgeObjectStorage:
		m.ClearObjectStorage()
		return nil
	}
	return fmt.Errorf("unknown PanierObjectStorage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PanierObjectStorageMutation) ResetEdge(name string) error {
	switch name {
	case panierobjectstorage.EdgePanier:
		m.ResetPanier()
		return nil
	case panierobjectstorage.EdgeObjectStorage:
		m.ResetObjectStorage()
		return nil
	}
	return fmt.Errorf("unknown PanierObjectStorage edge %s", name)
}
